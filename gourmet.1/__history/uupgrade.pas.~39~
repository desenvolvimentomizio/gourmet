unit uupgrade;

interface

uses Winapi.Windows, System.SysUtils,IdHTTP,
 inifiles, ShellApi, uni, Winapi.WinSock,IdURI, System.IOUtils,
 MySQLUniProvider,json,Vcl.Controls,Vcl.ExtCtrls,Vcl.Graphics,
 System.Net.HTTPClient, System.Net.URLClient,Vcl.Buttons,
 IdIcmpClient, IdStack, System.NetEncoding,
  Vcl.Forms, System.Classes, Vcl.Dialogs, System.DateUtils,
   RESTRequest4D, Vcl.ComCtrls;




function GetAppVersionStr(arq: string): string;
Procedure VerificarRelease;
procedure AtualizaRegrasTributarias;

const
  SUPABASE_URL = 'https://pejpkieipmfwjroqkkyu.supabase.co/functions/v1/regras-por-cnpj';
  SUPABASE_API_KEY   = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBlanBraWVpcG1md2pyb3Fra3l1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4Nzg1MDQsImV4cCI6MjA2ODQ1NDUwNH0.dRKW1j2_OKNqlolNQ7xND_3Wx6v5S1bYxOnmaBxGU6g';

const
  PORT_SERV : String = '8063';
  AIpServer: String = '181.216.47.70';
  URL_BASE: String = 'http://';

type
 TMeuEvento = procedure(Sender: TObject) of object;

  TMinhaClasse = class
  private
    FOnAcionar: TMeuEvento;
  public
    procedure Acionar; // método que dispara o evento
    property OnAcionar: TMeuEvento read FOnAcionar write FOnAcionar;
  end;


type

Tfaguarde = class(TForm)
private
  procedure BtOkClick(Sender: TObject);
end;


implementation

uses
  System.Variants;

function BuscarRegrasPorEmpresa(const ACNPJ: string): string;
var
  Resp: IResponse;
begin
    Showmessage('Vai conectar baixar regra: '+ACNPJ);


  Resp :=
    TRequest.New
      .BaseURL(SUPABASE_URL)
      .AddParam('cnpj', ACNPJ) // vai para a query string ?cnpj=...
      // Headers típicos para Edge Function pública:
      .TokenBearer(SUPABASE_API_KEY)
    //  .AddHeader('Authorization', 'Bearer ' + SUPABASE_API_KEY)
    //  .AddHeader('apikey', SUPABASE_API_KEY)
      .AddHeader('Accept', 'application/json')   // NÃO faça URL-encode disso
      // Em GET, não envie Content-Type
      .Get;

 { if (Resp.StatusCode < 200) or (Resp.StatusCode >= 300) then
    raise Exception.CreateFmt('Erro %d: %s', [Resp.StatusCode, Resp.Content]);}
  showmessage(Resp.Content);
  if Resp.Content='{"error":"No records found"}' then
    result:=''
  else
    Result := Resp.Content; // JSON retornado pela função
end;





procedure Tfaguarde.BtOkClick(Sender: TObject);
begin
  // Fecha o form “pai” do botão
  GetParentForm(TControl(Sender)).Close;
end;

procedure TMinhaClasse.Acionar;
begin
  if Assigned(FOnAcionar) then
    FOnAcionar(Self);  // dispara o evento, igual o OnClick faz
end;

Function SoNumeros(Const Texto: String): String;

Var
  i: Integer;
  S: String;
Begin
  S := '';
  For i := 1 To length(Texto) Do
  Begin
    If (Texto[i] In ['0' .. '9']) Then
    Begin
      S := S + Copy(Texto, i, 1);
    End;
  End;
  Result := S;
End;

function ShellExecute_AndWait(fileName: string; Params: string): bool;
var
  exInfo: TShellExecuteInfo;
  Ph: DWORD;
begin

  FillChar(exInfo, SizeOf(exInfo), 0);
  with exInfo do
  begin
    cbSize := SizeOf(exInfo);
    fMask := SEE_MASK_NOCLOSEPROCESS or SEE_MASK_FLAG_DDEWAIT;
    Wnd := GetActiveWindow();
    exInfo.lpVerb := 'open';
    exInfo.lpParameters := PChar(Params);
    lpFile := PChar(fileName);
    nShow := SW_SHOWNORMAL;
  end;
  if ShellExecuteEx(@exInfo) then
    Ph := exInfo.hProcess
  else
  begin
    ShowMessage(SysErrorMessage(GetLastError));
    Result := true;
    exit;
  end;
  while WaitForSingleObject(exInfo.hProcess, 50) <> WAIT_OBJECT_0 do
    Application.ProcessMessages;
  CloseHandle(Ph);

  Result := true;

end;

function ComputerName: String;
var
  buffer: array [0 .. 255] of char;
  size: DWORD;
begin
  size := 256;
  if GetComputerName(buffer, size) then
    Result := buffer
  else
    Result := ''
end;

function GetIP: string;
var
  WSAData: TWSADATA;
  HostEnt: PHostEnt;
  Name: string;
begin
  WSAStartup(2, WSAData);
  SetLength(Name, 255);
  GetHostName(PAnsiChar(Name), 255);
  SetLength(Name, StrLen(PChar(Name)));
  HostEnt := gethostbyname(PAnsiChar(Name));
  with HostEnt^ do
  begin
    Result := Format('%d.%d.%d.%d', [byte(h_addr^[0]), byte(h_addr^[1]), byte(h_addr^[2]), byte(h_addr^[3])]);
  end;
  WSACleanup;
end;

function DefineVertical: String;
var
  vlTipoVertical: string;
  vlPathAplicativo: string;
begin
  vlPathAplicativo := extractfilepath(Application.ExeName);

  if fileexists(vlPathAplicativo + 'GourmetERP.exe') then
    vlTipoVertical := 'gourmet'
  else if fileexists(vlPathAplicativo + 'MercatoERP.exe') then
    vlTipoVertical := 'mercato'
  else if fileexists(vlPathAplicativo + 'BoutiqueERP.exe') then
    vlTipoVertical := 'boutique'
  else if fileexists(vlPathAplicativo + 'VarejoERP.exe') then
    vlTipoVertical := 'varejo';

  Result := vlTipoVertical;

end;

function NotificaExecucaoVerificacao(aVersao: string): Boolean;
var
  vlArquIni: TInifile;
  vlNomeBanco: String;
  vlIpServidor: String;
  vlNome: String;
  vlUsuario: String;
  vlSenha: String;

var
  vlipmicro: string;
  vlNomeMicro: string;
  Conexaocloud: TUniConnection;
  Conexao: TUniConnection;
  MySQLUniProvider: TMySQLUniProvider;
  tla: TUniquery;
  gab: TUniquery;
  cfg: TUniquery;

  vlCnpj: string;
  vlApelido: string;
begin

  try
    vlNome := DefineVertical;

    if fileexists(extractfilepath(Application.ExeName) + vlNome + 'ERP.ini') then
      vlNome := extractfilepath(Application.ExeName) + vlNome + 'ERP.ini'
    else
      vlNome := extractfilepath(Application.ExeName) + 'pegasus.ini';

    vlArquIni := TInifile.Create(vlNome);

    With vlArquIni Do
    Begin
      vlNomeBanco := ReadString('posi', 'nomebanco', vlNome);
      vlIpServidor := ReadString('posi', 'servidor', '127.0.0.1');
      vlUsuario := ReadString('posi', 'usuario', 'root');
      vlSenha := ReadString('posi', 'senha', 'xda973');

    End;

    MySQLUniProvider := TMySQLUniProvider.Create(nil);

    try
      Conexao := TUniConnection.Create(nil);
      Conexao.ProviderName := 'MySQL';

      Conexao.Database := vlNomeBanco;
      Conexao.Server := vlIpServidor;

      Conexao.Password := vlSenha;
      Conexao.Username := vlUsuario;
      Conexao.Port := 3306;
      Conexao.Connect;
    except

      try
        Conexao.Server := '127.0.0.1';
        Conexao.Connect;
      except
        exit;
      end;

    end;

    cfg := TUniquery.Create(nil);
    cfg.Connection := Conexao;

    cfg.sql.Text := 'SELECT etd.etdapelido, etd.etddoc1  FROM   cfgmcfg,   etd ';
    cfg.sql.Add('WHERE etd.etdcodigo = cfgmcfg.cfgetdempresa AND cfgmcfg.cfgcodigo = 1 ');
    cfg.Open;

    vlCnpj := cfg.FieldByName('etddoc1').AsString;
    vlApelido := cfg.FieldByName('etdapelido').AsString;

    cfg.close;
    Conexao.Connected := false;



    try
      Conexaocloud := TUniConnection.Create(nil);
      Conexaocloud.ProviderName := 'MySQL';
      Conexaocloud.Database := 'empresa';
      Conexaocloud.Server := 'mysql.miziosistemas.com.br';
      Conexaocloud.Password := 'SuRiCa973';
      Conexaocloud.Username := 'root';
      Conexaocloud.Port := 8369;
      Conexaocloud.Connect;
    except

      try
        Conexaocloud.Server := '192.168.5.127';
        Conexaocloud.Connect;
      except
        exit;
      end;

    end;

    vlipmicro := GetIP;
    vlNomeMicro := ComputerName;

    tla := TUniquery.Create(nil);
    tla.Connection := Conexaocloud;

    tla.sql.Text := 'select tlachave, gabdoc1, tlaipmicro, tlaregistro, tlanomemicro ';
    tla.sql.Add('from tla where gabdoc1=:gabdoc1 and  tlaipmicro=:tlaipmicro');
    tla.ParamByName('gabdoc1').AsString := SoNumeros(vlCnpj);
    tla.ParamByName('tlaipmicro').AsString := vlipmicro;
    tla.Open;

    if tla.IsEmpty then
      tla.Append
    else
      tla.Edit;

    tla.FieldByName('gabdoc1').AsString := SoNumeros(vlCnpj);
    tla.FieldByName('tlaipmicro').AsString := vlipmicro;
    tla.FieldByName('tlanomemicro').AsString := vlNomeMicro;
    tla.FieldByName('tlaregistro').AsDateTime := now();
    tla.Post;

    gab := TUniquery.Create(nil);
    gab.Connection := Conexaocloud;
    gab.sql.Text := 'SELECT  gabchave,  gabdoc1,  gabnome,  gabbackup,  gabcontigencia, ';
    gab.sql.Add('gabcontigencias,  gabpendentes,  gabatualizacao,  gabversaoupdate FROM gab where gabdoc1=:gabdoc1');
    gab.Params[0].AsString := SoNumeros(vlCnpj);
    gab.Open;

    if gab.IsEmpty then
      gab.Append
    else
      gab.Edit;

    gab.FieldByName('gabdoc1').AsString := SoNumeros(vlCnpj);
    gab.FieldByName('gabnome').AsString := vlApelido;
    gab.FieldByName('gabatualizacao').AsDateTime := now();
    gab.FieldByName('gabversaoupdate').AsString := aVersao;
    gab.Post;

    tla.close;
    gab.close;

    Conexaocloud.Disconnect;


  finally

    vlArquIni.Free;

    cfg.DisposeOf;
    Conexao.DisposeOf;

    tla.DisposeOf;
    gab.DisposeOf;

    Conexaocloud.DisposeOf;

  end;

end;

function GetAppVersionStr(arq: string): string;
var
  Exe: string;
  size, Handle: DWORD;
  buffer: TBytes;
  FixedPtr: PVSFixedFileInfo;
begin
  try
    Exe := ParamSTR(0);
    size := GetFileVersionInfoSize(PChar(arq), Handle);
    if size = 0 then
      RaiseLastOSError;
    SetLength(buffer, size);
    if not GetFileVersionInfo(PChar(arq), Handle, size, buffer) then
      RaiseLastOSError;
    if not VerQueryValue(buffer, '\', pointer(FixedPtr), size) then
      RaiseLastOSError;

    Result := Format('%d.%s.%s.%s', [LongRec(FixedPtr.dwFileVersionMS).Hi, // major
      formatfloat('00', LongRec(FixedPtr.dwFileVersionMS).Lo), // minor
      formatfloat('0', LongRec(FixedPtr.dwFileVersionLS).Hi), // release
      formatfloat('0', LongRec(FixedPtr.dwFileVersionLS).Lo)]); // build

  except
    Result := '0.0.0.0';
  end;
end;


procedure FileSearch(const dirName: string; vListaVercoes: TStringList);
var
  searchResult: TSearchRec;
begin
  if FindFirst(dirName + '\*', faAnyFile, searchResult) = 0 then
  begin
    try
      repeat
        if (searchResult.Attr and faDirectory) = 0 then
        begin
          if SameText(ExtractFileExt(searchResult.Name), '.exe') then
          begin
            vListaVercoes.Add(IncludeTrailingBackSlash(dirName) + searchResult.Name);
          end;
        end;
      until FindNext(searchResult) <> 0 finally FindClose(searchResult);
    end;
  end;
end;

Function BaixarListaRealese(aVertical:string): String;
var
  resposta: IResponse;
  vlChavenfe: string;
  LStream: TStream;

  vlNomebck: string;
  vlNomeNew: string;



begin
  result := '';

  try

    resposta := TRequest.New.BaseURL(URL_BASE + AIpServer + ':' + PORT_SERV )
                         .Resource('/arquivos/'+aVertical)
                        .get;


    if (resposta.StatusCode = 200) or (resposta.StatusCode = 201) then
    begin
      result := resposta.Content;
    end
    else
      result :='';

  except
    result := '';
  end;

end;

function BaixarGET_RR4D(const BaseURL, Subpasta, NomeArq, PastaDestino: string): string;
var
  Http: THTTPClient;
  Url, Dest: string;
  FS: TFileStream;
begin
  try
  // Encode dos segmentos evita problemas com acentos/espaços/# etc.
  Url  := BaseURL + '/download/' + TIdURI.PathEncode(Subpasta) + '/' + TIdURI.PathEncode(NomeArq);
  Dest := TPath.Combine(PastaDestino, NomeArq);

  ForceDirectories(ExtractFileDir(Dest));

  Http := THTTPClient.Create;
  try
    Http.HandleRedirects := True;
    // Evite Brotli em 10.4 (não suportado nativamente)
    Http.CustomHeaders['Accept-Encoding'] := 'gzip, deflate'; // ou 'identity' p/ sem compressão

    FS := TFileStream.Create(Dest, fmCreate);
    try
      // Esse overload grava direto no arquivo (stream), sem conversão de texto
      Http.Get(Url, FS);
    finally
      FS.Free;
    end;
  finally
    Http.Free;
  end;
  except
   on E: Exception  do
    begin
      showmessage(e.Message);

    end;
  end;
end;

function DownloadArquivoGET_RR4D(const BaseURL, Subpasta, NomeArq, PastaDestino: string): string;
var
  Resp: IResponse;
  Resource, Dest: string;
  FS: TFileStream;
begin
  try
  Result := '';
  // Encode dos segmentos (evita erro de codepage / caracteres especiais)
  Resource := '/download/' + TIdURI.PathEncode(Subpasta) + '/' + TIdURI.PathEncode(NomeArq);

  Resp :=
    TRequest.New
      .BaseURL(BaseURL) // exemplo: http://127.0.0.1:8063  (sem "/" no final)
      .Resource(Resource)
      .Accept('application/octet-stream')
      .Get;

  if Resp.StatusCode = 200 then
  begin
    Dest := TPath.Combine(PastaDestino, NomeArq);
    ForceDirectories(ExtractFileDir(Dest));
    Resp.ContentStream.Position := 0;
    FS := TFileStream.Create(Dest, fmCreate);
    try
      FS.CopyFrom(Resp.ContentStream, Resp.ContentStream.Size);
    finally
      FS.Free;
    end;
    Result := Dest;
  end
  else
  begin
      showmessage(Resp.StatusText);
  end;
  except
   on E: Exception  do
    begin
      showmessage(e.Message);

    end;
  end;

end;



procedure BaixarComIndy(const AUrl, Destino: string);
var
  http: TIdHTTP;
  fs: TFileStream;
begin
  try
  http := TIdHTTP.Create(nil);
  try
    http.Request.CharSet := 'utf-8';
    http.Request.Accept := 'application/octet-stream';
    fs := TFileStream.Create(Destino, fmCreate);
    try
      http.Get(AUrl, fs);
    finally
      fs.Free;
    end;
  finally
    http.Free;

  end;
   except
    on E: Exception  do
    begin
      showmessage(e.Message);

    end;
  end;
end;


function BaixarRealese(const vArquivo, aVertical: string): string;
var
  resposta: IResponse;
  urlBase, resource, arqDestino: string;
  fs: TFileStream;
begin
  try
  Result := '';

  // 1) Monte a URL base sem o path
  urlBase := URL_BASE + AIpServer + ':' + PORT_SERV;

  // 2) Encode dos segmentos do path (resolve o erro de codepage)
  resource := '/download/' + TIdURI.PathEncode(aVertical) + '/' + TIdURI.PathEncode(vArquivo);

  // 3) Faça o GET aceitando binário
  resposta :=
    TRequest.New
      .BaseURL(urlBase)
      .Resource(resource)
      .AddHeader('Accept-Charset', 'utf-8')       // opcional, ajuda a evitar conversões indevidas
      .Accept('application/octet-stream')         // binário
      .Get;

  if (resposta.StatusCode = 200) or (resposta.StatusCode = 201) then
  begin
    // 4) Caminho de destino e criação da pasta
    arqDestino := TPath.Combine(
                    TPath.Combine(ExtractFilePath(ParamStr(0)), 'atualizadores_versao'),
                    vArquivo
                  );
    ForceDirectories(ExtractFileDir(arqDestino));

    // 5) Copiar o stream recebido para arquivo (binário, sem conversões)
    resposta.ContentStream.Position := 0; // garante início
    fs := TFileStream.Create(arqDestino, fmCreate);
    try
      fs.CopyFrom(resposta.ContentStream, resposta.ContentStream.Size);
    finally
      fs.Free;
    end;

    Result := arqDestino;
  end;
  except
    on E: Exception  do
    begin
      showmessage(e.Message);
       result := '';
    end;
  end;

end;




function ParseFirstJSONObjectFromText(const Raw: string): TJSONObject;
var
  i, startPos, depth: Integer;
  inStr: Boolean;
  ch, prev: Char;
  json: string;
begin
  Result := nil;

  // Opcional: remove aspas simples externas, se houver
  // Ex.: ' ... ' -> ...
  if (Raw.Length >= 2) and ((Raw[1] = '''') and (Raw[Raw.Length] = '''')) then
    json := Raw.Substring(1, Raw.Length - 2)
  else
    json := Raw;

  // Procura o primeiro '{'
  startPos := Pos('{', json);
  if startPos = 0 then
    raise Exception.Create('Não foi encontrado um objeto JSON na string.');

  // Caminha contando chaves, ignorando chaves dentro de strings
  depth := 0;
  inStr := False;
  prev := #0;

  for i := startPos to Length(json) do
  begin
    ch := json[i];

    // Alterna dentro/fora de string quando encontra aspas não escapadas
    if (ch = '"') and (prev <> '\') then
      inStr := not inStr;

    if not inStr then
    begin
      if ch = '{' then
        Inc(depth)
      else if ch = '}' then
      begin
        Dec(depth);
        if depth = 0 then
        begin
          // Fechou o objeto
          json := Copy(json, startPos, i - startPos + 1);
          Break;
        end;
      end;
    end;

    prev := ch;
  end;

  if (depth <> 0) or (json = '') or (json[1] <> '{') then
    raise Exception.Create('Objeto JSON incompleto ou inválido.');

  // Agora parseia
  Result := TJSONObject(TJSONObject.ParseJSONValue(json));
  if Result = nil then
    raise Exception.Create('Falha ao parsear o objeto JSON.');
end;


function PingWithIndy(const AHost: string; ATimeoutMs: Integer = 1000):Boolean;
var
  Ping: TIdIcmpClient;
begin
  result:=True;
  Ping := TIdIcmpClient.Create(nil);
  try
    Ping.Host := AHost;

    Ping.ReceiveTimeout := ATimeoutMs;  // tempo máximo de espera pela resposta

    try
      Ping.Ping; // envia 1 pacote
      if Ping.ReplyStatus.ReplyStatusType = rsEcho then
      else
        result:=False;

    except
      result:=false;
    end;

  finally
    Ping.Free;
  end;
end;



Procedure sincronizaVersoesServidor;
var
  ListaNomeArquivos:String;
  Obj: TJsonObject;
  qtd,i:Integer;
  NomeArq: String;
  arqlocal:String;
  faguarde:TForm;
  mostra:TProgressbar;
  a:String;
begin
  try
  try

    Obj := ParseFirstJSONObjectFromText(BaixarListaRealese(DefineVertical));


    qtd:=Obj.GetValue<Integer>('qtd');

    if Obj<>nil then
    begin
      if qtd>0 then
      begin
        faguarde:=TForm.Create(application);
        faguarde.Visible:=false;
        faguarde.Name:='fAguarde';
        faguarde.Caption:='Atualizando ...';
        faguarde.Width:=400;
        faguarde.Height:=150;
        faguarde.BorderIcons:=[];
        mostra:=TProgressbar.Create(faguarde);
        mostra.Parent:=faguarde;
        mostra.Align:=alClient;
        mostra.Max:=qtd;
        faguarde.WindowState:=wsNormal;
        faguarde.Position:=poScreenCenter;
        faguarde.FormStyle:=fsStayOnTop;



        for i := 1 to qtd do
        begin
          mostra.Position:=mostra.Position+1;
          application.ProcessMessages;
          NomeArq:='';
          NomeArq:=Obj.GetValue<String>('nome-'+i.ToString);

          if NomeArq<>'' then
          begin
            arqlocal:=Extractfilepath(application.ExeName)+'atualizadores_versao\'+NomeArq;

            if not DirectoryExists(Extractfilepath(arqlocal)) then
              ForceDirectories(Extractfilepath(arqlocal));


            if not fileexists(arqlocal) then
            begin
             faguarde.Visible:=true;
             faguarde.Show;
             BaixarGET_RR4D(URL_BASE+AIpServer+':'+PORT_SERV,DefineVertical,NomeArq ,Extractfilepath(application.ExeName)+'atualizadores_versao\');
            end;

          end;
        end;
        faguarde.Close;
        faguarde.Free;

      end;
    end;
  finally

  end;
  except

  end;
end;



procedure ExecutarEEsperar(const AFileName: string);
var
  SI: TStartupInfo;
  PI: TProcessInformation;
  ExitCode: Cardinal;
begin
  ZeroMemory(@SI, SizeOf(SI));
  SI.cb := SizeOf(SI);
  ZeroMemory(@PI, SizeOf(PI));

  if CreateProcess(nil, PChar(AFileName), nil, nil, False, 0, nil, nil, SI, PI) then
  begin
    // Espera o processo terminar
    WaitForSingleObject(PI.hProcess, INFINITE);

    // Opcional: pega o código de saída do programa
    GetExitCodeProcess(PI.hProcess, ExitCode);
   // Writeln('Programa terminou com código: ' + ExitCode.ToString);

    // Fecha handles
    CloseHandle(PI.hProcess);
    CloseHandle(PI.hThread);
  end
  else
    RaiseLastOSError;
end;

procedure bconfirmaClick(Sender: TObject);
begin
  if (sender is tpanel) then
  begin
    if ((sender as tpanel).parent is TForm) then
    begin
     ((sender as tpanel).parent as TForm).Close;
    end;
  end;
end;

procedure SpeedButtonClick(Sender: TObject);
begin
  ShowMessage('SpeedButton clicado: ' + (Sender as TSpeedButton).Caption);
end;

procedure BtOkClick(Sender: TObject);
begin

  ((Sender as TSpeedButton).Parent as TForm).Close;  // fecha o form, por exemplo
end;

function StringToJsonArray(const S: string; const RootArrayKey: string = ''): TJSONArray;
var
  V: TJSONValue;
  Arr: TJSONArray;
  Obj: TJSONObject;
  a:string;
begin
  // Parse usando UTF-8 (evita problemas de acentuação/BOM)
  V := TJSONObject.ParseJSONValue(TEncoding.UTF8.GetBytes(S), 0);
  if not Assigned(V) then
    raise Exception.Create('JSON inválido');

  try
    if V is TJSONArray then
      // Clona para não depender do objeto raiz
      Exit(TJSONArray(V.Clone));

    if V is TJSONObject then
    begin
      Obj := TJSONObject(V);
      // Se o array vier dentro de uma chave (p.ex. "data"), pegue e clone
      if RootArrayKey <> '' then
        Arr := Obj.GetValue<TJSONArray>(RootArrayKey)
      else
        Obj.TryGetValue<TJSONArray>('rows',Arr); // padrão comum

      a:= Arr.ToJSON;

      if not Assigned(Arr) then
      begin
        Result:=nil;
        exit;
      end
      else
      begin
        Exit(TJSONArray(Arr.Clone));
      end;
    end;

  finally
    V.Free; // liberamos o objeto raiz; retornamos um clone independente
  end;
end;


function IsoToBr(const Iso: string): string;
var dt: TDateTime;
begin
  if not TryISO8601ToDate(Iso, dt, False) then
    raise Exception.Create('Data ISO inválida');
  Result := FormatDateTime('dd"/"mm"/"yyyy"', dt);
end;

procedure AtualizaRegrasTributarias;
var
  vlArquIni: TInifile;
  vlNomeBanco: String;
  vlIpServidor: String;
  vlNome: String;
  vlUsuario: String;
  vlSenha: String;
  vlPortaBanco: String;

var
  vlipmicro: string;
  vlNomeMicro: string;
  Conexaocloud: TUniConnection;
  Conexao: TUniConnection;
  MySQLUniProvider: TMySQLUniProvider;
  cfg: TUniquery;
  nrt: TUniquery;
  vlCnpj: string;

var
  SRegras:String;
  ARegras:TJsonArray;
  i:Integer;

begin


  try
    vlNome := DefineVertical;

    if fileexists(extractfilepath(Application.ExeName) + vlNome + 'ERP.ini') then
      vlNome := extractfilepath(Application.ExeName) + vlNome + 'ERP.ini'
    else
      vlNome := extractfilepath(Application.ExeName) + 'pegasus.ini';

    vlArquIni := TInifile.Create(vlNome);

    Showmessage('Carregou o ini para ver da conexao');

    With vlArquIni Do
    Begin
      vlNomeBanco := ReadString('posi', 'nomebanco', vlNome);
      vlIpServidor := ReadString('posi', 'servidor', '127.0.0.1');
      vlUsuario := ReadString('posi', 'usuario', 'root');
      vlSenha := ReadString('posi', 'senha', 'xda973');
      vlPortaBanco := ReadString('posi', 'portabanco', '3306');
    End;

    MySQLUniProvider := TMySQLUniProvider.Create(nil);
    Showmessage('Vai conecata para pegar o cnpj');


    try
      Conexao := TUniConnection.Create(nil);
      Conexao.ProviderName := 'MySQL';

      Conexao.Database := vlNomeBanco;
      Conexao.Server := vlIpServidor;

      Conexao.Password := vlSenha;
      Conexao.Username := vlUsuario;

      if vlPortaBanco='' then
        vlPortaBanco:='3306';

      Conexao.Port := StrToInt(vlPortaBanco);
      Conexao.Connect;

    except
    on e: Exception do
      begin
        Showmessage('Falhou na conexao com o banco por: '+e.message );
      end;

    end;

    Showmessage('CNPJ para baixar regra: '+vlCnpj);

    cfg := TUniquery.Create(nil);
    cfg.Connection := Conexao;

    cfg.sql.Text := 'SELECT etd.etdapelido, etd.etddoc1  FROM   cfgmcfg,   etd ';
    cfg.sql.Add('WHERE etd.etdcodigo = cfgmcfg.cfgetdempresa AND cfgmcfg.cfgcodigo = 1 ');
    cfg.Open;

    vlCnpj := cfg.FieldByName('etddoc1').AsString;

    Showmessage('CNPJ para baixar regra: '+vlCnpj);

    cfg.close;
    Conexao.Connected := false;
    SRegras:= BuscarRegrasPorEmpresa(vlCnpj);

    if SRegras<>'' then
    begin
      ARegras :=TJSONArray.Create;
      ARegras := StringToJsonArray(SRegras);
      if ARegras<>nil then
      begin
        i:=ARegras.Count;

        if i>0 then
        begin

          nrt := TUniquery.Create(nil);
          nrt.Connection := Conexao;

          nrt.sql.Text := 'ALTER TABLE nrt '+
                          'CHANGE COLUMN csFcodigo csfcodigo VARCHAR(5) NOT NULL ';
          nrt.ExecSQL;

          nrt.sql.Text := 'SELECT '+
                          '  nrtcodigo, '+
                          '  crtcodigo, '+
                          '  nrtidentificacao, '+
                          '  nrtcfop_interno, '+
                          '  nrticm_interno, '+
                          '  nrtcfop_externo, '+
                          '  nrticm_externo, '+
                          '  nrtcombate_pobreza_aliquota, '+
                          '  nrtreducao_base_aliquota, '+
                          '  cstcodigo, '+
                          '  csicodigo, '+
                          '  cspcodigo, '+
                          '  pis_aliquota, '+
                          '  csfcodigo, '+
                          '  cofins_aliquota, '+
                          '  nrtclassificacao_is, '+
                          '  nrtclassificacao_ibscbs, '+
                          '  nrtclassificacao_cpresumido, '+
                          '  nrtibs_aliquota_estadual, '+
                          '  nrtibs_aliquota_municipal, '+
                          '  nrtdata_inicio, '+
                          '  nrtdata_fim, '+
                          '  nrtcbs_aliquota, '+
                          '  nrtreducao_cbs, '+
                          '  nrtreducao_ibs, '+
                          '  nrtcstibscbs '+
                          ' FROM nrt ';

          nrt.Open;

          for I := 0 to ARegras.Count-1 do
          begin


          if nrt.locate('nrtcodigo',
            VarArrayOf([ARegras[i].GetValue<string>('classificacao_ibscbs')]),[]) then
            nrt.edit
          else
          begin
            nrt.append;
            nrt.FieldByName('nrtcodigo').AsString:=ARegras[i].GetValue<string>('classificacao_ibscbs');
          end;

            nrt.FieldByName('crtcodigo').asInteger:=ARegras[i].GetValue<integer>('regime_id');
            nrt.FieldByName('nrtidentificacao').asstring:=ARegras[i].GetValue<String>('identificacao');
            nrt.FieldByName('nrtcfop_interno').asstring:=ARegras[i].GetValue<String>('cfop_interno');
            nrt.FieldByName('nrticm_interno').asFloat:=ARegras[i].GetValue<Double>('icm_interno');
            nrt.FieldByName('nrtcfop_externo').asstring:=ARegras[i].GetValue<String>('cfop_externo');
            nrt.FieldByName('nrticm_externo').asFloat:=ARegras[i].GetValue<Double>('icm_externo');
            nrt.FieldByName('nrtcombate_pobreza_aliquota').asFloat:=ARegras[i].GetValue<Double>('icm_externo');
            nrt.FieldByName('nrtreducao_base_aliquota').asFloat:=ARegras[i].GetValue<Double>('reducao_base_aliquota');
            nrt.FieldByName('cstcodigo').asstring:=ARegras[i].GetValue<String>('cst_icm_csosn');
            nrt.FieldByName('csicodigo').asstring:=ARegras[i].GetValue<String>('cst_ipi');
            nrt.FieldByName('cspcodigo').asstring:=ARegras[i].GetValue<String>('cst_pis');
            nrt.FieldByName('pis_aliquota').asFloat:=ARegras[i].GetValue<Double>('pis_aliquota');
            nrt.FieldByName('csfcodigo').asstring:=ARegras[i].GetValue<String>('cst_cofins');
            nrt.FieldByName('cofins_aliquota').asFloat:=ARegras[i].GetValue<Double>('cofins_aliquota');
            nrt.FieldByName('nrtclassificacao_is').asstring:=ARegras[i].GetValue<String>('classificacao_is');
            nrt.FieldByName('nrtclassificacao_ibscbs').asstring:=ARegras[i].GetValue<String>('classificacao_ibscbs');
            nrt.FieldByName('nrtcstibscbs').asstring:=ARegras[i].GetValue<String>('cst_ibscbs');
            nrt.FieldByName('nrtclassificacao_cpresumido').asstring:=ARegras[i].GetValue<String>('classificacao_cpresumido');
            nrt.FieldByName('nrtibs_aliquota_estadual').asFloat:=ARegras[i].GetValue<Double>('ibs_aliquota_estadual');
            nrt.FieldByName('nrtibs_aliquota_municipal').asFloat:=ARegras[i].GetValue<Double>('ibs_aliquota_municipal');
            nrt.FieldByName('nrtdata_inicio').asstring:=IsoToBr(ARegras[i].GetValue<String>('data_inicio'));

            if ARegras[i].GetValue<String>('data_fim')<>'' then
            begin
              nrt.FieldByName('nrtdata_fim').asstring:=IsoToBr(ARegras[i].GetValue<String>('data_fim'));
            end;

            nrt.FieldByName('nrtcbs_aliquota').asFloat:=ARegras[i].GetValue<Double>('cbs_aliquota');
            nrt.FieldByName('nrtreducao_cbs').asFloat:=ARegras[i].GetValue<Double>('reducao_cbs');
            nrt.FieldByName('nrtreducao_ibs').asFloat:=ARegras[i].GetValue<Double>('reducao_ibs');
            nrt.Post;
          end;

        end;

      end;
    end;


  finally

  end;

end;

Procedure VerificarRelease;
var
  vlVersao: String;
  arquini: TInifile;
  vlListaVersoes: TStringList;
  vlVersaoArquivo: string;
  vlarquivo: string;
  vlatualizador: string;
  searchResult: TSearchRec;
  i: Integer;

  vlNumeroVersao: string;

  plMensagem1:TPanel;
  plMensagem2:TPanel;
  plMensagem3:TPanel;
  btOk:TSpeedButton;

begin

  AtualizaRegrasTributarias;


  if PingWithIndy(AIpServer) then
  begin

    sincronizaVersoesServidor;

    vlVersao := GetAppVersionStr(Application.ExeName);
    vlVersao := stringreplace(vlVersao, '.', '', [rfReplaceAll, rfIgnoreCase]);

    arquini := TInifile.Create(extractfilepath(Application.ExeName) + DefineVertical + 'erp.ini');
    arquini.WriteString('posi', 'Versao', vlVersao);
    arquini.Free;

    vlListaVersoes := TStringList.Create;

    FileSearch(extractfilepath(Application.ExeName) + 'atualizadores_versao', vlListaVersoes);

    vlListaVersoes.Sorted:=True;

    for i := 0 to vlListaVersoes.Count - 1 do
    begin

      vlarquivo := vlListaVersoes.Strings[i];
      vlVersaoArquivo := SoNumeros(vlarquivo);

      if strtofloat(vlVersao) < strtofloat(vlVersaoArquivo) then
      begin

        vlatualizador := vlarquivo;

        if fileexists(vlatualizador) then
        begin
          Application.Terminate;

          ShellExecute_AndWait(vlatualizador, '  /silent /nocancel  /ALLUSERS ');

          // NotificaExecucaoVerificacao(vlNumeroVersao);


        end;
      end;

    end;

    vlNumeroVersao := GetAppVersionStr(Application.ExeName);

   //  NotificaExecucaoVerificacao(vlNumeroVersao);

  end;

end;

end.
