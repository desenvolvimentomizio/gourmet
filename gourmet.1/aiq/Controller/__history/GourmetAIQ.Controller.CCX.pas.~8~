unit GourmetAIQ.Controller.CCX;

interface

uses
  REST.Types,
  System.Json,
  REST.Json,
  REST.Client,
  DataSetConverter4D,
  DataSetConverter4D.Impl,

  GourmetAIQ.DataModulo.CCX,
  GourmetAIQ.Service.Funcoes,
  GourmetAIQ.DataModulo.Connection;

function BuscacznChaveAberta: Integer;

implementation

uses
  System.SysUtils;

function BuscacznChaveAberta: Integer;
var
  vDMccx: TDMccx;
  vlCznChave: Integer;
  vlJSONData: TJsonvalue;
  vlItensczn: TJsonarray;

  texto: string;
begin

  try
    vlJSONData := Nil;
    vlItensczn := NIl;

    vDMccx := TDMccx.Create(nil);

    vDMccx.RESTRequestGourmet.Method := TRESTRequestMethod.rmGET;
    vDMccx.RESTResponseGourmet.ContentType := 'application/json; charset=utf-8';
    try
      vDMccx.RESTRequestGourmet.Execute;
    except
      sleep(2000);
      try
        vDMccx.RESTRequestGourmet.Execute;
      except
        vlCznChave := 0;
        exit;
      end;
    end;

    if vDMccx.RESTResponseGourmet.StatusCode = 200 then
    begin

      vlJSONData := TJSONObject.ParseJSONValue(vDMccx.RESTResponseGourmet.Content, False);
      if vlJSONData <> nil then
      begin
        texto := vlJSONData.ToString;

        vlItensczn := TJsonarray.Create;
        vlItensczn := vlJSONData.getvalue<TJsonarray>;

        vlCznChave := vlItensczn[0].getvalue('cznchave', '').ToInteger;
      end
      else
      begin
        vlCznChave := 0;
      end;

    end;
    if vlCznChave <> 0 then
    begin
      result := vlCznChave;
    end
    else
    begin
      result := 0;
    end;

  finally
    vDMccx.free;
  end;

end;

end.
