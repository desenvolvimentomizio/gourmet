<?xml version="1.0" encoding="utf-8"?>
<namespace name="ZXing.OneD.OneDReader" platform="Android">
  <class name="TOneDReader" file="ZXing.OneD.OneDReader.pas" line="42">
    <devnotes>
       <summary>
       Encapsulates functionality and implementation that is common to all families
       of one-dimensional barcodes.
       </summary>
    </devnotes>
    <ancestor name="TInterfacedObject" namespace="System">
      <interfaces>
        <implements name="IInterface" />
      </interfaces>
      <methodref name="GetRefCount" visibility="private" procflags="inline">
      </methodref>
      <methodref name="__MarkDestroying" visibility="protected" procflags="static inline">
      </methodref>
      <methodref name="QueryInterface" visibility="protected">
      </methodref>
      <methodref name="_AddRef" visibility="protected">
      </methodref>
      <methodref name="_Release" visibility="protected">
      </methodref>
      <methodref name="AfterConstruction" visibility="public" procflags="override">
      </methodref>
      <methodref name="BeforeDestruction" visibility="public" procflags="override">
      </methodref>
      <methodref name="NewInstance" visibility="public" procflags="class override">
      </methodref>
      <propertyref name="RefCount" visibility="public">
      </propertyref>
      <ancestor name="TObject" namespace="System">
        <methodref name="Create" visibility="public" procflags="constructor">
        </methodref>
        <methodref name="Free" visibility="public">
        </methodref>
        <methodref name="DisposeOf" visibility="public" procflags="inline">
        </methodref>
        <methodref name="InitInstance" visibility="public" procflags="class">
        </methodref>
        <methodref name="CleanupInstance" visibility="public">
        </methodref>
        <methodref name="ClassType" visibility="public" procflags="inline">
        </methodref>
        <methodref name="ClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassNameIs" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassParent" visibility="public" procflags="class">
        </methodref>
        <methodref name="ClassInfo" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InstanceSize" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="InheritsFrom" visibility="public" procflags="class">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodAddress" visibility="public" procflags="class overload">
        </methodref>
        <methodref name="MethodName" visibility="public" procflags="class">
        </methodref>
        <methodref name="QualifiedClassName" visibility="public" procflags="class">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="FieldAddress" visibility="public" procflags="overload">
        </methodref>
        <methodref name="GetInterface" visibility="public">
        </methodref>
        <methodref name="GetInterfaceEntry" visibility="public" procflags="class">
        </methodref>
        <methodref name="GetInterfaceTable" visibility="public" procflags="class inline">
        </methodref>
        <methodref name="UnitName" visibility="public" procflags="class">
        </methodref>
        <methodref name="UnitScope" visibility="public" procflags="class">
        </methodref>
        <methodref name="Equals" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetHashCode" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="ToString" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="SafeCallException" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="AfterConstruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="BeforeDestruction" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Dispatch" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="DefaultHandler" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="NewInstance" visibility="public" procflags="class virtual">
        </methodref>
        <methodref name="FreeInstance" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="Destroy" visibility="public" procflags="destructor virtual">
        </methodref>
        <methodref name="CPP_ABI_1" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="CPP_ABI_2" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="CPP_ABI_3" visibility="public" procflags="virtual">
        </methodref>
        <methodref name="GetDisposed" visibility="protected" procflags="inline">
        </methodref>
        <methodref name="CheckDisposed" visibility="protected" procflags="inline">
        </methodref>
        <propertyref name="Disposed" visibility="protected">
        </propertyref>
      </ancestor>
    </ancestor>
    <interfaces>
      <implements name="IReader" />
    </interfaces>
    <members>
      <function name="doDecode" visibility="private" file="ZXing.OneD.OneDReader.pas" line="56">
        <devnotes>
           <summary>
           We're going to examine rows from the middle outward, searching alternately above and below the
           middle, and farther out each time. rowStep is the number of rows between each successive
           attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then
           middle + rowStep, then middle - (2 * rowStep), etc.
           rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily
           decided that moving up and down by about 1/16 of the image is pretty good; we try more of the
           image if &quot;trying harder&quot;.
           </summary>
           <param name="image">The image to decode</param>
           <param name="hints">Any hints that were requested</param>
           <returns>The contents of the decoded barcode</returns>
        </devnotes>
        <parameters>
          <parameter name="image" type="TBinaryBitmap" paramflags="const" />
          <parameter name="hints" type="TDictionary&lt;ZXing.DecodeHintType.TDecodeHintType,System.TObject&gt;" />
          <retval type="TReadResult" />
        </parameters>
      </function>
      <procedure name="InitializeClass" visibility="private" procflags="static" file="ZXing.OneD.OneDReader.pas" line="58">
      </procedure>
      <field name="INTEGER_MATH_SHIFT" type="Integer" visibility="protected" varflags="class" file="ZXing.OneD.OneDReader.pas" line="60" />
      <field name="PATTERN_MATCH_RESULT_SCALE_FACTOR" type="Integer" visibility="protected" varflags="class" file="ZXing.OneD.OneDReader.pas" line="61" />
      <function name="patternMatchVariance" visibility="protected" procflags="static" file="ZXing.OneD.OneDReader.pas" line="75">
        <devnotes>
           <summary>
           Determines how closely a set of observed counts of runs of black/white values matches a given
           target pattern. This is reported as the ratio of the total variance from the expected pattern
           proportions across all pattern elements, to the length of the pattern.
           </summary>
           <param name="counters">observed counters</param>
           <param name="pattern">expected pattern</param>
           <param name="maxIndividualVariance">The most any counter can differ before we give up</param>
           <returns>ratio of total variance between counters and pattern compared to total pattern size,
           where the ratio has been multiplied by 256. So, 0 means no variance (perfect match); 256 means
           the total variance between counters and patterns equals the pattern length, higher values mean
           even more variance</returns>
        </devnotes>
        <parameters>
          <parameter name="counters" type="TArray&lt;System.Integer&gt;" />
          <parameter name="pattern" type="TArray&lt;System.Integer&gt;" />
          <parameter name="maxIndividualVariance" type="Integer" />
          <retval type="Integer" />
        </parameters>
      </function>
      <function name="RecordPatternInReverse" visibility="protected" procflags="static" file="ZXing.OneD.OneDReader.pas" line="85">
        <devnotes>
           <summary>
           Records the pattern in reverse.
           </summary>
           <param name="row">The row.</param>
           <param name="start">The start.</param>
           <param name="counters">The counters.</param>
           <returns></returns>
        </devnotes>
        <parameters>
          <parameter name="row" type="IBitArray" />
          <parameter name="start" type="Integer" />
          <parameter name="counters" type="TArray&lt;System.Integer&gt;" />
          <retval type="Boolean" />
        </parameters>
      </function>
      <function name="recordPattern" visibility="protected" procflags="static overload" file="ZXing.OneD.OneDReader.pas" line="98">
        <devnotes>
           <summary>
           Records the size of successive runs of white and black pixels in a row, starting at a given point.
           The values are recorded in the given array, and the number of runs recorded is equal to the size
           of the array. If the row starts on a white pixel at the given start point, then the first count
           recorded is the run of white pixels starting from that point; likewise it is the count of a run
           of black pixels if the row begin on a black pixels at that point.
           </summary>
           <param name="row">row to count from</param>
           <param name="start">offset into row to start at</param>
           <param name="counters">array into which to record counts</param>
        </devnotes>
        <parameters>
          <parameter name="row" type="IBitArray" />
          <parameter name="start" type="Integer" />
          <parameter name="counters" type="TArray&lt;System.Integer&gt;" />
          <parameter name="numCounters" type="Integer" />
          <retval type="Boolean" />
        </parameters>
      </function>
      <procedure name="reset" visibility="public" procflags="virtual" file="ZXing.OneD.OneDReader.pas" line="106">
        <devnotes>
           <summary>
           Resets any internal state the implementation has after a decode, to prepare it
           for reuse.
           </summary>
        </devnotes>
      </procedure>
      <function name="decode" visibility="public" procflags="overload" file="ZXing.OneD.OneDReader.pas" line="114">
        <devnotes>
           <summary>
           Locates and decodes a barcode in some format within an image.
           </summary>
           <param name="image">image of barcode to decode</param>
           <returns>
           String which the barcode encodes
           </returns>
        </devnotes>
        <parameters>
          <parameter name="image" type="TBinaryBitmap" paramflags="const" />
          <retval type="TReadResult" />
        </parameters>
      </function>
      <function name="decode" visibility="public" procflags="overload virtual" file="ZXing.OneD.OneDReader.pas" line="128">
        <devnotes>
<!-- Badly formed XML comment ignored for member 'decode' -->
        </devnotes>
        <parameters>
          <parameter name="image" type="TBinaryBitmap" paramflags="const" />
          <parameter name="hints" type="TDictionary&lt;ZXing.DecodeHintType.TDecodeHintType,System.TObject&gt;" />
          <retval type="TReadResult" />
        </parameters>
      </function>
      <function name="recordPattern" visibility="public" procflags="static overload" file="ZXing.OneD.OneDReader.pas" line="142">
        <devnotes>
           <summary>
           Records the size of successive runs of white and black pixels in a row, starting at a given point.
           The values are recorded in the given array, and the number of runs recorded is equal to the size
           of the array. If the row starts on a white pixel at the given start point, then the first count
           recorded is the run of white pixels starting from that point; likewise it is the count of a run
           of black pixels if the row begin on a black pixels at that point.
           </summary>
           <param name="row">row to count from</param>
           <param name="start">offset into row to start at</param>
           <param name="counters">array into which to record counts</param>
        </devnotes>
        <parameters>
          <parameter name="row" type="IBitArray" />
          <parameter name="start" type="Integer" />
          <parameter name="counters" type="TArray&lt;System.Integer&gt;" />
          <retval type="Boolean" />
        </parameters>
      </function>
      <function name="decodeRow" visibility="public" procflags="abstract virtual" file="ZXing.OneD.OneDReader.pas" line="155">
        <devnotes>
<!-- Badly formed XML comment ignored for member 'decodeRow' -->
        </devnotes>
        <parameters>
          <parameter name="rowNumber" type="Integer" paramflags="const" />
          <parameter name="row" type="IBitArray" paramflags="const" />
          <parameter name="hints" type="TDictionary&lt;ZXing.DecodeHintType.TDecodeHintType,System.TObject&gt;" paramflags="const" />
          <retval type="TReadResult" />
        </parameters>
      </function>
    </members>
  </class>
</namespace>
