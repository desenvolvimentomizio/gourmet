unit ufPrinciMonitorProducao;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs,TlHelp32, Vcl.StdCtrls, Vcl.ExtCtrls,
  RESTRequest4D, shellapi, Vcl.Menus, System.ImageList, Vcl.ImgList,
  IdBaseComponent, IdAntiFreezeBase, IdAntiFreeze, Registry, inifiles;

type
  TfPrinciMonitorProducao = class(TForm)
    relogioProducao: TTimer;
    Memo1: TMemo;
    PopupMenu: TPopupMenu;
    MOSTRARImpressor: TMenuItem;
    OCULTARImpressor: TMenuItem;
    N1: TMenuItem;
    Fechar: TMenuItem;
    OcultarInicial: TTimer;
    plMonitorProducao: TPanel;
    PnlDataHoraProducao: TPanel;
    plProducaoStatus: TPanel;
    IdAntiFreeze1: TIdAntiFreeze;
    ImageList1: TImageList;
    TrayIcon: TTrayIcon;
    plMonitorAIQFome: TPanel;
    PnlDataHoraAIQFome: TPanel;
    plAiqFomeStatus: TPanel;
    PlMonitorMenuvem: TPanel;
    PnlDataHoraMeNuvem: TPanel;
    plMeNuvemStatus: TPanel;
    PlMonitorWhatsapp: TPanel;
    PnlDataHoraWhatsapp: TPanel;
    plWhatsappStatus: TPanel;
    relogioAiqFome: TTimer;
    relogioMeNuvem: TTimer;
    relogioWhatsApp: TTimer;
    PlMonitorServidorArquivos: TPanel;
    PnlDataHoraServidorArquivos: TPanel;
    plStatusServidorArquivos: TPanel;
    relogioServidorArquivos: TTimer;
    procedure relogioProducaoTimer(Sender: TObject);

    procedure MOSTRARImpressorClick(Sender: TObject);
    procedure OCULTARImpressorClick(Sender: TObject);
    procedure OcultarInicialTimer(Sender: TObject);
    procedure FecharClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormShow(Sender: TObject);
    procedure relogioServidorArquivosTimer(Sender: TObject);
    procedure relogioAiqFomeTimer(Sender: TObject);
    procedure relogioMeNuvemTimer(Sender: TObject);
    procedure relogioWhatsAppTimer(Sender: TObject);
  private
    vpMostrar : Boolean;
    vlContador:Integer;
    vlTentativas:Integer;

    function processExists(exeFileName: string): Boolean;
    function KillProcessTree(const PID: Cardinal): boolean;
    function processKill(exeFileName: string): Boolean;
    procedure RunOnStartup;
    procedure CarregaIni;
    Procedure VerificaStatusPrograma(aPorta:String; aExecutavel:string; aTimer:TTimer; aPainel:TPanel; aPainelHora:TPanel);

    { Private declarations }
  public
    { Public declarations }
     vpServidor:String;
  end;

var
  fPrinciMonitorProducao: TfPrinciMonitorProducao;

implementation

{$R *.dfm}
function TfPrinciMonitorProducao.processKill(exeFileName: string): Boolean;
{description checks if the process is running
URL: http://www.swissdelphicenter.ch/torry/showcode.php?id=2554}
var
  ContinueLoop: BOOL;
  FSnapshotHandle: THandle;
  FProcessEntry32: TProcessEntry32;
begin
  FSnapshotHandle        := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  FProcessEntry32.dwSize := SizeOf(FProcessEntry32);
  ContinueLoop           := Process32First(FSnapshotHandle, FProcessEntry32);
  Result := False;


  while Integer(ContinueLoop) <> 0 do
  begin

    if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) =
      UpperCase(ExeFileName)) or (UpperCase(FProcessEntry32.szExeFile) =
      UpperCase(ExeFileName))) then
    begin
      Result := True;
      KillProcessTree(FProcessEntry32.th32ProcessID);
    end;

    ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32);
  end;
  CloseHandle(FSnapshotHandle);
end;



function TfPrinciMonitorProducao.processExists(exeFileName: string): Boolean;
{description checks if the process is running
URL: http://www.swissdelphicenter.ch/torry/showcode.php?id=2554}
var
  ContinueLoop: BOOL;
  FSnapshotHandle: THandle;
  FProcessEntry32: TProcessEntry32;
begin
  FSnapshotHandle        := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  FProcessEntry32.dwSize := SizeOf(FProcessEntry32);
  ContinueLoop           := Process32First(FSnapshotHandle, FProcessEntry32);
  Result := False;


  while Integer(ContinueLoop) <> 0 do
  begin

    if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) =
      UpperCase(ExeFileName)) or (UpperCase(FProcessEntry32.szExeFile) =
      UpperCase(ExeFileName))) then
    begin
      Result := True;
    end;

    ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32);
  end;
  CloseHandle(FSnapshotHandle);
end;

Procedure  TfPrinciMonitorProducao.VerificaStatusPrograma(aPorta:String; aExecutavel:string; aTimer:TTimer; aPainel:TPanel; aPainelHora:TPanel);
var
  LResponse: IResponse;
begin
  try
    try
      aPainelHora.Caption:=timetostr(time());
      aTimer.Enabled:=False;

      LResponse := TRequest.New.BaseURL('http://'+vpServidor+':'+aPorta+'/test')
        .Accept('application/json')
        .Get;

      if LResponse.StatusCode = 200 then
      begin
        aPainel.Color:=clgreen;
        vlContador:=0;
      end
      else
      begin

        if fileexists(extractfilepath(application.ExeName)+aExecutavel) then
        begin

          Memo1.lines.Add(DateTimetoStr(now())+ ' Tentativa de conecao '+ LResponse.Content);
          aPainel.Color:=clred;
          vlContador:=vlContador+1;

          if vlContador=5 then
          begin
            // Memo1.Lines.Clear;
             Memo1.lines.Add(DateTimetoStr(now())+ '  vai reinicia o serviço');
             if processExists(aExecutavel) then
               processKill(aExecutavel);

             while vlTentativas<=10 do
             begin

               ShellExecute(Handle, 'open', PChar(extractfilepath(application.ExeName)+aExecutavel), nil, nil, SW_SHOW);
               sleep(3000);
               if processExists(aExecutavel) then
               begin
                 Memo1.lines.Add(DateTimetoStr(now())+ ' Tentativa de execução do serviço '+vlTentativas.ToString);
                 break
               end
               else
                 begin
                   Memo1.lines.Add(DateTimetoStr(now())+ ' Tentativa de execução do serviço '+vlTentativas.ToString);
                   vlTentativas:=vlTentativas+1;
                 end;

             end;

             Memo1.lines.Add(DateTimetoStr(now())+ ' serviço reiniciado com sucesso');

          end;
        end
        else
        begin
          aPainel.Color:=clred;
          vlContador:=vlContador+1;
        end;
      end;
    except
     on E: Exception do
        begin
        Memo1.lines.Add(DateTimetoStr(now())+ ' Erro de conexao '+ e.Message);

        vlContador:=vlContador+1;

        if fileexists(extractfilepath(application.ExeName)+aExecutavel) then
        begin

          if vlContador=5 then
          begin
             //Memo1.Lines.Clear;
             Memo1.lines.Add(DateTimetoStr(now())+ '  vai reinicia o serviço');
             if processExists(aExecutavel) then
               processKill(aExecutavel);

             while vlTentativas<=10 do
             begin

               ShellExecute(Handle, 'open', PChar(extractfilepath(application.ExeName)+aExecutavel), nil, nil, SW_SHOW);
               sleep(3000);
               if processExists(aExecutavel) then
               begin
                 Memo1.lines.Add(DateTimetoStr(now())+ ' Tentativa de execução do serviço '+vlTentativas.ToString);
                 break
               end
               else
                 begin
                   Memo1.lines.Add(DateTimetoStr(now())+ ' Tentativa de execução do serviço '+vlTentativas.ToString);
                   vlTentativas:=vlTentativas+1;
                 end;

             end;

             Memo1.lines.Add(DateTimetoStr(now())+ ' serviço reiniciado com sucesso');

          end;
        end;

      end;
    end;
  finally
    aTimer.Enabled:=true;
  end;
end;

procedure TfPrinciMonitorProducao.relogioProducaoTimer(Sender: TObject);
begin
//  VerificaStatusPrograma('9191','ProducaoUPServer.exe',relogioProducao,plProducaoStatus, PnlDataHoraProducao );
end;


procedure TfPrinciMonitorProducao.relogioAiqFomeTimer(Sender: TObject);
begin

//  VerificaStatusPrograma('9192','ProducaoUPServer.exe',relogioProducao,plProducaoStatus, PnlDataHoraProducao );

end;

procedure TfPrinciMonitorProducao.relogioMeNuvemTimer(Sender: TObject);
begin
//  VerificaStatusPrograma('9193','ProducaoUPServer.exe',relogioProducao,plProducaoStatus, PnlDataHoraProducao );

end;

procedure TfPrinciMonitorProducao.relogioWhatsAppTimer(Sender: TObject);
begin
//  VerificaStatusPrograma('9194','ProducaoUPServer.exe',relogioProducao,plProducaoStatus, PnlDataHoraProducao );

end;


procedure TfPrinciMonitorProducao.relogioServidorArquivosTimer(Sender: TObject);
begin
//  VerificaStatusPrograma('9195','MizioServidorArquivo.exe',relogioServidorArquivos,plStatusServidorArquivos, PnlDataHoraServidorArquivos );
end;


procedure TfPrinciMonitorProducao.FecharClick(Sender: TObject);
begin
  OcultarInicial.Enabled:=false;

  relogioProducao.Enabled := false;
  relogioAiqFome.Enabled := false;
  relogioMeNuvem.Enabled := false;
  relogioWhatsApp.Enabled := false;
  relogioServidorArquivos.Enabled := false;

  application.Terminate;

end;

Procedure TfPrinciMonitorProducao.RunOnStartup;
Var
  sKey: String;
  reg: TRegIniFile;
Begin

  sKey := 'GourmetMonitorProducao';
  reg := TRegIniFile.Create('');
  reg.RootKey := HKEY_LOCAL_MACHINE;
  reg.WriteString('Software\Microsoft\Windows\CurrentVersion\Run' + sKey + #0, sKey, application.ExeName);

  reg.Free;
End;


procedure TfPrinciMonitorProducao.FormCreate(Sender: TObject);
begin
   RunOnStartup;
   vpMostrar := false;
end;

Procedure TfPrinciMonitorProducao.CarregaIni;
Var
  arquini: TIniFile;
Begin

  arquini :=TIniFile.Create(extractfilepath(application.exename)+'gourmeterp.ini');
  With arquini Do
  Begin
    vpServidor := ReadString('posi', 'servidor', '127.0.0.1');
  End;
  arquini.Free;

End;



procedure TfPrinciMonitorProducao.FormShow(Sender: TObject);
begin
  CarregaIni;
  OcultarInicial.Enabled := True;
  relogioProducao.Enabled:=True;
  relogioAiqFome.Enabled := True;
  relogioMeNuvem.Enabled := True;
  relogioWhatsApp.Enabled := True;
  relogioServidorArquivos.Enabled := True;
end;

function TfPrinciMonitorProducao.KillProcessTree(const PID: Cardinal): boolean;
var hProc, hSnap,
    hChildProc  : THandle;
    pe          : TProcessEntry32;
    bCont       : BOOL;
begin
    Result := true;
    FillChar(pe, SizeOf(pe), #0);
    pe.dwSize := SizeOf(pe);

    hSnap := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hSnap <> INVALID_HANDLE_VALUE) then
    begin
        if (Process32First(hSnap, pe)) then
        begin
            hProc := OpenProcess(PROCESS_TERMINATE{PROCESS_ALL_ACCESS}, false, PID);

            if (hProc <> 0) then
            begin
                Result := Result and TerminateProcess(hProc, 1);
                WaitForSingleObject(hProc, INFINITE);
                CloseHandle(hProc);
            end;

            bCont := true;
            while bCont do
            begin
                if (pe.th32ParentProcessID = PID) then
                begin
                    KillProcessTree(pe.th32ProcessID);

                    hChildProc := OpenProcess(PROCESS_TERMINATE{PROCESS_ALL_ACCESS}, FALSE, pe.th32ProcessID);

                    if (hChildProc <> 0) then
                    begin
                        Result := Result and TerminateProcess(hChildProc, 1);
                        WaitForSingleObject(hChildProc, INFINITE);
                        CloseHandle(hChildProc);
                    end;
                end;
                bCont := Process32Next(hSnap, pe);
            end;
        end;

        CloseHandle(hSnap);
    end;
end;


procedure TfPrinciMonitorProducao.MOSTRARImpressorClick(Sender: TObject);
begin

  vpMostrar := True;

end;

procedure TfPrinciMonitorProducao.OCULTARImpressorClick(Sender: TObject);
begin

  vpMostrar := False;
end;

procedure TfPrinciMonitorProducao.OcultarInicialTimer(Sender: TObject);
begin

  application.MainForm.Visible := vpMostrar;
  if vpMostrar then
  begin
    self.WindowState := wsNormal;
  end;

end;

Procedure prcFinalizaPrograma(const ExeFileName : string);
{==============================================================================}
{  Autor: Gustavo Zicatti Raimundo.                                            }
{  Data de criação: 03/01/2006.                                                }
{  Objetivo:                                                                   }
{  Finaliza um aplicativo aberto apartir do nome do arquivo.                   }
{  Observações:                                                                }
{  Deve-se declarar na uses da unit o TlHelp32 que contém a função             }
{      CreateToolHelp32Snapshot que é utilizada para capturar as informações   }
{      da fila de processos na memória.                                        }
{==============================================================================}
const
    PROCESS_TERMINATE = $0001;
var
    {Handle para um conjunto de informações sobre os processos da memória}
    hdSnapshot      : THandle;
    {Informações sobre um determinado processo em memória}
    fProcessEntry32 : TProcessEntry32;
    {Controle de looping}
    bContinueLoop   : BOOL;
begin
    {Cria um Handle para as informações dos processos em memória}
    hdSnapshot:=CreateToolHelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    {Define o tamanho da estrutura tProcessEntry32}
    fProcessEntry32.dwSize:=SizeOf(fProcessEntry32);
    {Captura o primeiro processo na fila da memória}
    bContinueLoop:=Process32First(hdSnapshot, fProcessEntry32);
    {Enquanto não se acabarem os processos em memória}
    while not(Integer(bContinueLoop) = 0) do
    begin
        {Se o processo atual contiver o nome definido no parametro ExeFileName}
        if
            (UpperCase(ExtractFileName(fProcessEntry32.szExeFile)) = UpperCase(ExeFileName))
            or
            (UpperCase(fProcessEntry32.szExeFile) = UpperCase(ExeFileName))
        then
        begin
            {Então este processo será finalizado}
            TerminateProcess(OpenProcess(PROCESS_TERMINATE, BOOL(0), fProcessEntry32.th32ProcessID), 0);
        end;
        {Captura o próximo processo em memória}
        bContinueLoop:=Process32Next(hdSnapshot, fProcessEntry32);
    end;
    {Fecha o Handle da memória}
    CloseHandle(hdSnapshot);
end;

function Killtask2(exefilename: string): integer;
Const
  process_terminate = $0001;
Var
  Continueloop: Bool;
  Fsnapshothandle: THandle;
  fprocessentry32: TProcessentry32;
Begin
 Result := 0;
 Fsnapshothandle := CreateToolhelp32Snapshot (Th32cs_snapprocess, 0);
 FProcessEntry32.dwsize := Sizeof(FPROCESSENTRY32);
 Continueloop := Process32First (Fsnapshothandle, FPROCESSENTRY32);
 while integer (continueloop) <> 0 do begin
    if (Uppercase(Extractfilename (FProcessEntry32. szexefile)) = Uppercase(Exefilename))
    or (Uppercase(FProcessEntry32. Szexefile) = Uppercase(Exefilename)) then
    Result := Integer(TerminateProcess(OpenProcess(Process_terminate, BOOL (0), FProcessEntry32. Th32processid), 0));
    Continueloop := Process32Next(Fsnapshothandle, FPROCESSENTRY32);
  end;
  CloseHandle(Fsnapshothandle);
End;


end.
