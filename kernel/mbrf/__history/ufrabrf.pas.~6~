unit ufrabrf;

interface

uses
  Winapi.Windows, Vcl.Forms, ufrabase, Data.DB, Vcl.StdCtrls, Vcl.Mask,
  Vcl.DBCtrls, VirtualTable, MemDS, DBAccess, Uni, Vcl.Menus, System.Classes,
  System.Actions, Vcl.ActnList, Vcl.Buttons, Vcl.Grids, Vcl.DBGrids,
  Vcl.Imaging.jpeg, Vcl.ExtCtrls, Vcl.Imaging.pngimage, Vcl.Controls,
  Vcl.Dialogs, Vcl.Graphics, System.SysUtils, System.Math, System.Types,
  System.Variants, uFuncoes, uPegaBase, Vcl.ComCtrls, System.ImageList,
  Vcl.ImgList,  Xml.xmldom, Xml.XMLIntf, Xml.XMLDoc, dateutils;

type
  TRecebCaixa = Record
    Conta: Integer;
    Cliente: Integer;
  end;

type

  Tfrabrf = class(Tfrabase)
    lte: tuniquery;
    lteltechave: TIntegerField;
    lteltedata: TDateField;
    ltelteprincipal: TFloatField;
    lteltejuros: TFloatField;
    lteltedesconto: TFloatField;
    lteltetotal: TFloatField;
    ltelteextenso: TStringField;
    lteltehistorico: TStringField;
    Dlte: tunidatasource;
    PlTotal: TPanel;
    GBTotalABaixar: TGroupBox;
    ltetotal: TDBEdit;
    GBDescontoABaixar: TGroupBox;
    bdiluirdesconto: TButton;
    ltedesconto: TDBEdit;
    GBJurosABaixar: TGroupBox;
    bajustarjuros: TButton;
    ltejuros: TDBEdit;
    GBPrincipalABaixar: TGroupBox;
    lteprincipal: TDBEdit;
    mfi: tuniquery;
    uqtabelarfichave: TIntegerField;
    uqtabelaetdcodigo: TIntegerField;
    uqtabelaetdidentificacao: TStringField;
    uqtabelarfiemissao: TDateField;
    uqtabelarfivencimento: TDateField;
    uqtabelarfivalor: TFloatField;
    uqtabelarfinumero: TStringField;
    uqtabelasrfcodigo: TIntegerField;
    uqtabelaflacodigo: TIntegerField;
    uqtabelabcocodigo: TStringField;
    uqtabelarfihistorico: TStringField;
    mfimfichave: TIntegerField;
    mfirfichave: TIntegerField;
    mfitmfcodigo: TIntegerField;
    mfimoecodigo: TIntegerField;
    mfimfivalor: TFloatField;
    mfimfidata: TDateField;
    mfimfihistorico: TStringField;
    mfimfivalorori: TFloatField;
    mfimfiparcela: TIntegerField;
    mlt: tuniquery;
    mltmltchave: TIntegerField;
    mltmfichave: TIntegerField;
    mltltechave: TIntegerField;
    ActIncluirTodos: TAction;
    ActIncluirSelecionado: TAction;
    ActRemoverTodos: TAction;
    ActRemoverSelecionado: TAction;
    GBselecionados: TGroupBox;
    DBGListaSelecionados: TDBGrid;
    PlBotoesRemover: TPanel;
    BRemoverTodos: TBitBtn;
    BRemoverSelecionado: TBitBtn;
    GroupBox5: TGroupBox;
    plbotoesincluir: TPanel;
    BIncluirTodos: TBitBtn;
    BIncluirSelecionado: TBitBtn;
    GroupBox4: TGroupBox;
    GroupBox3: TGroupBox;
    GroupBox2: TGroupBox;
    GroupBox1: TGroupBox;
    GroupBox6: TGroupBox;
    PlQtdeRest: TPanel;
    PlQtdeBaixa: TPanel;
    PlPrincipal: TPanel;
    PlDescont: TPanel;
    PlJuros: TPanel;
    PlTot: TPanel;
    extrfi: tuniquery;
    cfg: tuniquery;
    cfgcfgdtinictb: TDateField;
    uqtabelarfijuros: TFloatField;
    uqtabelarfimulta: TFloatField;
    uqtabelarfidesconto: TFloatField;
    GroupBox7: TGroupBox;
    PlMultas: TPanel;
    GBMultasABaixar: TGroupBox;
    bajustarmultas: TButton;
    ltemulta: TDBEdit;
    lteltemulta: TFloatField;
    tabela: TVirtualTable;
    tabelarfichave: TIntegerField;
    tabelaetdcodigo: TIntegerField;
    tabelaetdidentificacao: TStringField;
    tabelarfinumero: TStringField;
    tabelarfiemissao: TDateField;
    tabelarfivencimento: TDateField;
    tabelarfivalor: TFloatField;
    tabelarfihistorico: TStringField;
    tabelarfidtultbaixa: TDateField;
    tabelabcocodigo: TStringField;
    tabelarfimoradia: TFloatField;
    tabelarfijuros: TFloatField;
    vbaixa: TVirtualTable;
    vbaixarfichave: TIntegerField;
    vbaixaetdcodigo: TIntegerField;
    vbaixaetdidentificacao: TStringField;
    vbaixarfinumero: TStringField;
    vbaixarfiemissao: TDateField;
    vbaixarfivencimento: TDateField;
    vbaixarfivalor: TFloatField;
    vbaixarfihistorico: TStringField;
    vbaixarfidtultbaixa: TDateField;
    vbaixabcocodigo: TStringField;
    vbaixarfisituacao: TStringField;
    vbaixarfimoradia: TFloatField;
    vbaixarfijuros: TFloatField;
    vbaixarfidias: TIntegerField;
    vbaixarfidescontos: TFloatField;
    Dvbaixa: tunidatasource;
    btAjustar: TBitBtn;
    uqtabelarfidtultbaixa: TDateField;
    uqtabelarfimoradia: TFloatField;
    tabelasrfcodigo: TIntegerField;
    tabelarfimulta: TFloatField;
    tabelarfidesconto: TFloatField;
    ltetfdcodigo: TIntegerField;
    vbaixarfimulta: TFloatField;
    tabelaincluido: TIntegerField;
    ConsultaMfi: tuniquery;
    vbaixarfimorarecebida: TFloatField;
    vbaixarfimoradispensada: TFloatField;
    vbaixarfimultarecebida: TFloatField;
    vbaixarfimultadispensada: TFloatField;
    uqtabelarfibaixadocapital: TFloatField;
    uqtabelarfisaldocapital: TFloatField;
    uqtabelarfisaldogeral: TFloatField;
    tabelarfibaixadocapital: TFloatField;
    tabelarfisaldocapital: TFloatField;
    tabelarfisaldogeral: TFloatField;
    vbaixarfibaixadocapital: TFloatField;
    vbaixarfisaldocapital: TFloatField;
    vbaixarfisaldogeral: TFloatField;
    vbaixarfimoraoriginal: TFloatField;
    vbaixarfimultaoriginal: TFloatField;
    vbaixarfibaixado: TFloatField;
    vbaixarfiemaberto: TFloatField;
    vbaixarfipgtocapital: TFloatField;
    vbaixarfidescoriginal: TFloatField;
    vbaixarfidiferenca: TFloatField;
    IdentificaBaixa: tuniquery;
    PMGerador: TPopupMenu;
    mGerador: TMenuItem;
    VTBaixaLte: TVirtualTable;
    VTBaixaLteltechave: TIntegerField;
    DVTBaixaLte: tunidatasource;
    VTBaixaLteQtdRegistros: TIntegerField;
    tabelarfidias: TIntegerField;
    bBaixaParcial: TBitBtn;
    bAjustarTodos: TBitBtn;
    VTBaixaLterfichave: TIntegerField;
    VTBaixaLteetdcodigo: TIntegerField;
    VTBaixaLteetdidentificacao: TStringField;
    VTBaixaLterfinumero: TStringField;
    VTBaixaLterfiemissao: TDateField;
    VTBaixaLterfivencimento: TDateField;
    VTBaixaLterfihistorico: TStringField;
    VTBaixaLterfidtultbaixa: TDateField;
    VTBaixaLterfidias: TIntegerField;
    VTBaixaLterfimoradia: TFloatField;
    VTBaixaLtebcocodigo: TStringField;
    VTBaixaLterfisituacao: TStringField;
    VTBaixaLterfivalor: TFloatField;
    VTBaixaLterfibaixadocapital: TFloatField;
    VTBaixaLterfisaldocapital: TFloatField;
    VTBaixaLterfijuros: TFloatField;
    VTBaixaLterfimulta: TFloatField;
    VTBaixaLterfidescontos: TFloatField;
    VTBaixaLterfisaldogeral: TFloatField;
    VTBaixaLterfimoraoriginal: TFloatField;
    VTBaixaLterfimorarecebida: TFloatField;
    VTBaixaLterfimoradispensada: TFloatField;
    VTBaixaLterfimultaoriginal: TFloatField;
    VTBaixaLterfimultarecebida: TFloatField;
    VTBaixaLterfimultadispensada: TFloatField;
    VTBaixaLterfibaixado: TFloatField;
    VTBaixaLterfiemaberto: TFloatField;
    VTBaixaLterfipgtocapital: TFloatField;
    VTBaixaLterfidescoriginal: TFloatField;
    VTBaixaLterfidiferenca: TFloatField;
    uqtabelarfisaldomora: TFloatField;
    tabelarfisaldomora: TFloatField;
    vbaixarfisaldomora: TFloatField;
    cltv: tuniquery;
    adc: tuniquery;
    adcadccodigo: TIntegerField;
    adcadcidentificacao: TStringField;
    adcetdcodigo: TIntegerField;
    uqtabelarfidias: TIntegerField;
    let: tuniquery;
    letltechave: TIntegerField;
    letetdcodigo: TIntegerField;
    letletchave: TIntegerField;
    cfgcfgusactb: TIntegerField;
    tabelabolnossonumero: TStringField;
    uqtabelabolnossonumero: TStringField;
    cfgcfgusabol: TIntegerField;
    uqtabelatfiidentificacao: TStringField;
    tabelatfiidentificacao: TStringField;
    cfgcfgdatapadrao: TDateField;
    Panel1: TPanel;
    GroupBox8: TGroupBox;
    diabaixa: TDateTimePicker;
    bBuscaClientes: TBitBtn;
    mfiflacodigo: TIntegerField;
    tabelarfimarca: TIntegerField;
    uqtabelarfimarca: TIntegerField;
    mostra: TProgressBar;
    tabelameschave: TIntegerField;
    uqtabelameschave: TIntegerField;
    cfgcfgctbusaccg: TIntegerField;
    mcgrfi: tuniquery;
    mcgrfirfichave: TIntegerField;
    mcgrfimfivalor: TFloatField;
    mcgrficcgcodigo: TIntegerField;
    mcg: tuniquery;
    mcgmcgchave: TIntegerField;
    mcgccgcodigo: TIntegerField;
    mcgmcgvalor: TFloatField;
    mcgmcgdata: TDateField;
    mcgmcgtabela: TStringField;
    mcgmcgchaveorigem: TIntegerField;
    mcgmcgsituacao: TIntegerField;
    mcgclbcodigo: TIntegerField;
    mcgmcgregistro: TDateTimeField;
    mcgrfichave: TIntegerField;
    cfgccgmultajuros: TIntegerField;
    mcgrfimcgvalor: TFloatField;
    rfi: tuniquery;
    mcgrfirfivalor: TFloatField;
    mcgrfitmfcodigo: TIntegerField;
    tabelarfidatadesc: TDateField;
    tabelarfivalodesc: TFloatField;
    tabelarfidatamulta: TDateField;
    tabelarfivalomulta: TFloatField;
    uqtabelarfidatadesc: TDateField;
    uqtabelarfivalodesc: TFloatField;
    uqtabelarfidatamulta: TDateField;
    uqtabelarfivalomulta: TFloatField;
    procedure lteAfterInsert(DataSet: TDataSet);
    procedure DBGListaDblClick(Sender: TObject);
    procedure DBGListaSelecionadosDblClick(Sender: TObject);
    procedure ActIncluirTodosExecute(Sender: TObject);
    procedure ActIncluirSelecionadoExecute(Sender: TObject);
    procedure ActRemoverTodosExecute(Sender: TObject);
    procedure ActAtualizarExecute(Sender: TObject);
    procedure btAjustarClick(Sender: TObject);
    procedure ActRemoverSelecionadoExecute(Sender: TObject);
    procedure DBGListaDrawColumnCell(Sender: TObject; const Rect: TRect; DataCol: Integer; Column: TColumn; State: TGridDrawState);
    procedure DBGListaSelecionadosDrawColumnCell(Sender: TObject; const Rect: TRect; DataCol: Integer; Column: TColumn; State: TGridDrawState);
    procedure mGeradorClick(Sender: TObject);
    procedure DBGListaKeyPress(Sender: TObject; var Key: Char);
    procedure edbuscaKeyPress(Sender: TObject; var Key: Char);
    procedure bBaixaParcialClick(Sender: TObject);
    procedure bAjustarTodosClick(Sender: TObject);
    procedure ActSairExecute(Sender: TObject);
    procedure bBuscaClientesClick(Sender: TObject);
    procedure uqtabelaBeforeOpen(DataSet: TDataSet);
    procedure DBGListaCellClick(Column: TColumn);
    procedure diabaixaChange(Sender: TObject);
  private

    (* Valores Originais *)
    FSaldoGeralOrig: Double;
    FDescontoOrig: Double;
    FMoraOrig: Double;
    FMultaOrig: Double;
    FSaldoCapitalOrig: Double;

    (* Diferenças *)
    FDifSaldoCapital: Double;
    FDifMora: Double;
    FDifMulta: Double;
    FDifDesconto: Double;
    FDifSaldoGeral: Double;
    FRenegociacao: Boolean;

    function AjustarTodos: Boolean;
    procedure AjustaBaixaParcial(vValor: Double);
    procedure somarbaixa;
    procedure TransferirItem;
    procedure RegistraMFI(tmfCodigo: Integer; valor: currency);
    procedure ajustatiposdemovimento;
    procedure AtualizaRFI;
    procedure AtualizaDVTBaixaLte;
    procedure RemoveTituloSelecionado;
    procedure SetRenegociacao(const Value: Boolean);
    function ContabilizarBaixaRfi(vLteChave: string; vtdgcodigo: Integer; vCcoChave: string): Boolean;
    procedure TransferirTodosItem;
    { Private declarations }

  published
    procedure Carregar; override;

    (* Valores Originais *)
    property SaldoCapitalOrig: Double read FSaldoCapitalOrig write FSaldoCapitalOrig;
    property MultaOrig: Double read FMultaOrig write FMultaOrig;
    property MoraOrig: Double read FMoraOrig write FMoraOrig;
    property DescontoOrig: Double read FDescontoOrig write FDescontoOrig;
    property SaldoGeralOrig: Double read FSaldoGeralOrig write FSaldoGeralOrig;

    (* Diferenças *)
    property DifSaldoCapital: Double read FDifSaldoCapital write FDifSaldoCapital;
    property DifMulta: Double read FDifMulta write FDifMulta;
    property DifMora: Double read FDifMora write FDifMora;
    property DifDesconto: Double read FDifDesconto write FDifDesconto;
    property DifSaldoGeral: Double read FDifSaldoGeral write FDifSaldoGeral;

    (* Identifica se é Renegociação *)
    property Renegociacao: Boolean read FRenegociacao write SetRenegociacao default False;
  public
    { Public declarations }
    vpccxchave:integer;
    vpalavra: string;
    vtfdcodigo: string;

    vpTmfBaixas: Integer;
    vpTmfDescontos: Integer;

    vpTmfMultaRegistro: Integer;
    vpTmfMultaDispensada: Integer;
    vpTmfMultaPaga: Integer;

    vpTmfMoraRegistro: Integer;
    vpTmfMoraDispensada: Integer;
    vpTmfMoraPaga: Integer;

    RecebCaixa: TRecebCaixa;

    procedure LimpaRegistros;
    function Finaliza: Boolean;
    procedure RegistraMovimentos;
    procedure carregadados;
    procedure calculartotais;

  end;

  TContabilizacaoBaixaRfi = function(AOwner: TComponent; conexao: tuniconnection; vusuario: string; vLteChave: string; vtdgcodigo: string;
    vCcoChave: string): Boolean;

var
  frabrf: Tfrabrf;

implementation

{$R *.dfm}

uses ufajusta, ufAjustaTotal;

type
  { expor propriedades e metodso privadas e protegindos do dbgrid }
  TFriendly = class(TCustomDBGrid);

procedure Tfrabrf.calculartotais;
var
  regatual: Integer;
  vprincipal: Double;
  vjuros: Double;
  vdesconto: Double;
  vmulta: Double;
  vtotal: Double;

  qt: Integer;

begin
  { if edbusca.Text = '' then
    exit; }

  regatual := tabela.RecNo;

  regatual := Self.tabela.RecNo;
  tabela.First;

  vprincipal := 0;
  vjuros := 0;
  vdesconto := 0;
  vmulta := 0;
  vtotal := 0;

  qt := 0;

  tabela.DisableControls;
  tabela.First;
  while not Self.tabela.Eof do
  begin
    if Self.tabelarfisaldogeral.AsFloat > 0 then
    begin
      qt := qt + 1;
      vprincipal := vprincipal + Self.tabelarfisaldocapital.AsFloat;
      vjuros := vjuros + Self.tabelarfijuros.AsFloat;
      vdesconto := vdesconto + Self.tabelarfidesconto.AsFloat;
      vmulta := vmulta + Self.tabelarfimulta.AsFloat;
      vtotal := vtotal + Self.tabelarfisaldogeral.AsFloat;
    end;
    Self.tabela.Next;
  end;

  tabela.EnableControls;

  PlQtdeRest.Caption := IntToStr(qt);
  PlPrincipal.Caption := Format('%12.2n', [vprincipal]);
  PlDescont.Caption := Format('%12.2n', [vdesconto]);
  PlJuros.Caption := Format('%12.2n', [vjuros]);
  PlMultas.Caption := Format('%12.2n', [vmulta]);

  PlTot.Caption := Format('%12.2n', [vtotal]);

  Self.tabela.RecNo := regatual;

end;

Procedure Tfrabrf.carregadados;
Var
  i: Integer;
Begin

  { if edbusca.Text = '' then
    exit; }

  tabela.Open;
  tabela.Clear;

  tabela.DisableControls;
  vbaixa.DisableControls;
  try
    (* Insere na VirtualTable os títulos Em Aberto para baixa. *)
    uqtabela.First;
    While Not uqtabela.Eof Do
    Begin
      tabela.Append;

      For i := 0 To 21 Do
        tabela.Fields[i].AsString := uqtabela.Fields[i].AsString;

      if (Self.tabelasrfcodigo.AsInteger = srfEmAberto) then
        Self.tabelarfidtultbaixa.AsString := '';

      tabelarfisaldomora.AsCurrency := uqtabelarfisaldomora.AsCurrency;

      if vbaixa.Locate('rfichave', tabelarfichave.AsInteger, []) then
        tabelaincluido.AsInteger := 1
      else
        tabelaincluido.AsInteger := 0; // "Incluido" identifica se um título já foi marcado para baixa ou não.

      tabelarfimarca.AsInteger := 0;

      consulta.Close;
      consulta.SQL.Text := 'select meschave from rfm where rfichave=' + tabelarfichave.AsString;
      consulta.Open;

      if not consulta.IsEmpty then
      begin
        if consulta.FieldByName('meschave').AsString <> '' then
          tabelameschave.AsString := consulta.FieldByName('meschave').AsString;

      end;

      tabelarfidatadesc.AsFloat := uqtabelarfidatadesc.AsFloat;
      tabelarfivalodesc.AsFloat := uqtabelarfivalodesc.AsFloat;
      tabelarfidatamulta.AsFloat := uqtabelarfidatamulta.AsFloat;
      tabelarfivalomulta.AsFloat := uqtabelarfivalomulta.AsFloat;

      tabela.Post;
      uqtabela.Next;
    End;
  finally

    tabela.EnableControls;
    vbaixa.EnableControls;
  end;
End;

procedure Tfrabrf.ActAtualizarExecute(Sender: TObject);
begin
  if Self.vtfdcodigo = '' then
    exit;

  cfg.Open;

  If Not vbaixa.Active Then
    vbaixa.Open;

  uqtabela.ParamByName('tfdcodigo').AsString := vtfdcodigo;
  uqtabela.ParamByName('clbcodigo').AsInteger := acesso.Usuario;



  // uqtabela.Params[0].AsString := Self.vtfdcodigo;
  // uqtabela.Params[1].AsInteger := Self.Acesso.usuario;

  inherited;

  carregadados;

  if edbusca.Text <> '' then
  begin
    calculartotais;
  end;
end;

procedure Tfrabrf.ActIncluirSelecionadoExecute(Sender: TObject);
var
  vlRecno: Integer;
Begin

  tabela.Next;

  vlRecno := tabelarfichave.AsInteger;

  if not tabela.Eof then
    tabela.Prior
  else
    tabela.Next;

  if tabelarfimarca.AsInteger = 0 then
  begin
    tabela.Edit;
    tabelarfimarca.AsInteger := 1;
    tabela.Post;
  end;

  TransferirItem;

  tabela.Locate('rfichave', vlRecno, []);

  // DBGLista.Repaint;
end;

procedure Tfrabrf.bAjustarTodosClick(Sender: TObject);
Begin
  If vbaixa.IsEmpty Then
    exit;

  AjustarTodos;
end;

procedure Tfrabrf.bBaixaParcialClick(Sender: TObject);
var
  vsValorBxParcial: String;
  vlValorBxParcial: Double;

  vlSaldoBxParcial: Double;
  vlValorBaixado: Double;
  vlRegAjustado: Boolean;
  vlRecno: Integer;

begin
  if not InputQuery('Baixa Parcial', 'Valor para Baixa Parcial: ', vsValorBxParcial) then
    exit
  else
    try
      vlValorBxParcial := StrToFloat(vsValorBxParcial)
    except
      ShowMessage('Informe valor válido!');
      exit;
    end;

  if (vlValorBxParcial <= 0) then
  begin
    Application.MessageBox(PChar('Valor inválido!'), 'Atenção', MB_ICONWARNING + MB_OK);
    exit;
  end;

  vlRecno := 0;
  vlRegAjustado := False;
  vlValorBaixado := 0;
  vlSaldoBxParcial := 0;

  vbaixa.DisableControls;

  try
    vbaixa.First;
    while not vbaixa.Eof do
    begin

      vlValorBaixado := vlValorBaixado + vbaixarfibaixado.AsCurrency;

      case CompareValue(vlValorBaixado, vlValorBxParcial) of
        EqualsValue:
          begin
            vlRecno := vbaixa.RecNo;
            vlRegAjustado := True;
            vbaixa.Next;
          end;
        LessThanValue:
          vbaixa.Next;

        GreaterThanValue:
          if (vlRegAjustado) then
          begin
            if (vbaixa.RecNo > vlRecno) then
              RemoveTituloSelecionado
            else
              vbaixa.Next;
          end
          else
          begin
            vbaixa.Edit;

            vlSaldoBxParcial := vlValorBaixado - vlValorBxParcial;
            vlSaldoBxParcial := vbaixarfibaixado.AsCurrency - vlSaldoBxParcial;

            if vbaixarfimultarecebida.AsCurrency >= vlSaldoBxParcial then
            begin
              vbaixarfimultarecebida.AsCurrency := vlSaldoBxParcial;
              vlSaldoBxParcial := 0;
            end
            else
              vlSaldoBxParcial := vlSaldoBxParcial - vbaixarfimultarecebida.AsCurrency;

            if vbaixarfimorarecebida.AsCurrency >= vlSaldoBxParcial then
            begin
              vbaixarfimorarecebida.AsCurrency := vlSaldoBxParcial;
              vlSaldoBxParcial := 0;
            end
            else
              vlSaldoBxParcial := vlSaldoBxParcial - vbaixarfimorarecebida.AsCurrency;

            vbaixarfipgtocapital.AsFloat := vlSaldoBxParcial;

            vbaixarfiemaberto.AsCurrency := vbaixarfisaldocapital.AsCurrency - vbaixarfipgtocapital.AsCurrency;

            If vbaixarfiemaberto.AsCurrency = 0 Then
              Self.vbaixarfisituacao.AsString := 'Baixa Total'
            Else
              Self.vbaixarfisituacao.AsString := 'Baixa Parcial';

            vbaixarfimulta.AsCurrency := vbaixarfimultarecebida.AsCurrency;
            vbaixarfijuros.AsCurrency := vbaixarfimorarecebida.AsCurrency;

            vbaixarfibaixado.AsCurrency := vbaixarfipgtocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency -
              vbaixarfidescontos.AsCurrency;

            vbaixarfisaldogeral.AsCurrency := vbaixarfisaldocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency -
              vbaixarfidescontos.AsCurrency;

            vlRecno := vbaixa.RecNo;
            vlRegAjustado := True;
            vbaixa.Next;
          end;
      end;
    end;

    somarbaixa;
    calculartotais;

  finally
    vbaixa.EnableControls;
  end;
end;

procedure Tfrabrf.bBuscaClientesClick(Sender: TObject);
var
  vlEtdCodigo: String;
begin
  vlEtdCodigo := MostraLista('mcli', 'etdcodigo <> 0');

  if vlEtdCodigo = '' then
    exit;

  uqtabela.Filter := 'etdcodigo = ' + vlEtdCodigo;

  ActAtualizar.Execute;
end;

procedure Tfrabrf.btAjustarClick(Sender: TObject);
Var
  frmAjusta: tfajusta;
Begin
  If vbaixa.IsEmpty Then
    exit;

  frmAjusta := tfajusta.Create(Self);
  frmAjusta.vpUsuario := acesso.Usuario.ToString;
  frmAjusta.zcone := zcone;
  frmAjusta.vpLteChave := lteltechave.AsString;
  frmAjusta.vpUsrCodigo := acesso.Usuario.ToString;
  frmAjusta.Dvbaixa.DataSet := vbaixa;

  frmAjusta.Dvbaixa.DataSet.Edit;

  If frmAjusta.ShowModal = mrOk Then
  Begin
    vbaixarfiemaberto.AsCurrency := vbaixarfisaldocapital.AsCurrency - vbaixarfipgtocapital.AsCurrency;

    If vbaixarfiemaberto.AsCurrency = 0 Then
      Self.vbaixarfisituacao.AsString := 'Baixa Total'
    Else
      Self.vbaixarfisituacao.AsString := 'Baixa Parcial';

    vbaixarfijuros.AsCurrency := vbaixarfimorarecebida.AsCurrency;
    vbaixarfimulta.AsCurrency := vbaixarfimultarecebida.AsCurrency;

    vbaixarfisaldogeral.AsCurrency := vbaixarfisaldocapital.AsCurrency + vbaixarfijuros.AsCurrency + vbaixarfimulta.AsCurrency - vbaixarfidescontos.AsCurrency;

    vbaixa.Post;
  End;

  somarbaixa;
  calculartotais;
end;

procedure Tfrabrf.ActIncluirTodosExecute(Sender: TObject);
var
  smsg: string;
  i: Integer;
  vlRecno: Integer;
begin

  smsg := 'Confirma a inclusão de ' + IntToStr(uqtabela.RecordCount) + ' registros para quitação ?';

  If Application.MessageBox(PChar(smsg), 'Atenção', MB_YESNO + MB_DEFBUTTON1 + MB_ICONQUESTION) = IDNO Then
    exit;

  try
    mostra.Visible := True;
    tabela.DisableControls;
    if not tabela.Active then
      tabela.Open;

    { tabela.First;
      while not tabela.Eof do
      begin
      tabela.Edit;
      tabelarfimarca.AsInteger := 1;
      tabela.Post;

      tabela.Next;
      end; }

    If Not vbaixa.Active Then
      vbaixa.Open;

    tabela.First;
    mostra.Max := tabela.RecordCount;
    mostra.Position := 0;
    While Not tabela.Eof Do
    begin
      mostra.Position := mostra.Position + 1;
      Application.ProcessMessages;
      Self.TransferirTodosItem;
      tabela.Next;
    end;

    mostra.Position := 0;
    mostra.Visible := False;

    for i := 0 to 50 do
    begin
      tabela.First;
      while not tabela.Eof do
      begin
        tabela.Edit;
        tabelaincluido.AsInteger := 1;
        tabela.Post;

        tabela.Next;
      end;
    end;

    somarbaixa;
  finally
    calculartotais;
    tabela.EnableControls;
  end;
end;

procedure Tfrabrf.RemoveTituloSelecionado;
var
  vrfichaveatu: Integer;
begin
  if vbaixa.IsEmpty then
    exit;

  vrfichaveatu := Self.vbaixarfichave.AsInteger;
  vbaixa.Delete;

  tabela.DisableControls;
  tabela.Filtered := False;

  tabela.Locate('rfichave', vrfichaveatu, []);

  tabela.Edit;
  tabelaincluido.AsInteger := 0;
  tabelarfimarca.AsInteger := 0;
  tabela.Post;

  tabela.Filtered := True;
  tabela.Locate('rfichave', vrfichaveatu, []);
  tabela.EnableControls;

end;

procedure Tfrabrf.SetRenegociacao(const Value: Boolean);
begin
  FRenegociacao := Value;
end;

procedure Tfrabrf.ActRemoverSelecionadoExecute(Sender: TObject);
begin
  RemoveTituloSelecionado;

  somarbaixa;
  calculartotais;
end;

procedure Tfrabrf.ActRemoverTodosExecute(Sender: TObject);
begin
  if not vbaixa.Active then
    exit;
  vbaixa.First;

  While Not vbaixa.Eof Do
    RemoveTituloSelecionado;

  somarbaixa;
  Self.calculartotais;
end;

procedure Tfrabrf.ActSairExecute(Sender: TObject);
begin
  SalvarColunas(DBGListaSelecionados);

  inherited;
end;

procedure Tfrabrf.DBGListaCellClick(Column: TColumn);
begin
  // inherited;
  if Column.FieldName = 'rfimarca' then
  begin
    (* Pode fazer assim - Gabriel - 2014-02-06 1323 *)
    tabela.Edit;
    if tabela.FieldByName('rfimarca').AsString = '1' then
    begin
      tabela.FieldByName('rfimarca').AsString := '0'
    end
    else
    begin
      tabela.FieldByName('rfimarca').AsString := '1';
    end;
    tabela.Post;

  end
  else
  begin
    // inherited;
  end;

end;

procedure Tfrabrf.DBGListaDblClick(Sender: TObject);
begin
  ActIncluirSelecionado.Execute;
end;

procedure Tfrabrf.DBGListaDrawColumnCell(Sender: TObject; const Rect: TRect; DataCol: Integer; Column: TColumn; State: TGridDrawState);
var
  fixRect: TRect;
  Check: Integer;
  R: TRect;
  i: Integer;

begin

  fixRect := Rect;

  If Odd(DSTabela.DataSet.RecNo) Then
  begin
    DBGLista.Canvas.Brush.Color := PEG_COR_BASE;
  end
  else
  begin
    DBGLista.Canvas.Brush.Color := CLWHITE;
  end;

  if Self.tabelasrfcodigo.AsInteger IN [srfQuitado, srfRenegociado] then
  begin
    DBGLista.Canvas.Font.Color := clGreen;
    DBGLista.Canvas.Font.style := [];
  end
  else if ((tabelasrfcodigo.AsInteger = srfEmAberto) or (Self.tabelasrfcodigo.AsInteger = srfBaixaParcial)) then
    if (tabelarfivencimento.AsFloat >= Self.cfgcfgdatapadrao.AsFloat) then
    begin
      DBGLista.Canvas.Font.Color := clBlack;
      DBGLista.Canvas.Font.style := [];
    end
    else
    begin
      DBGLista.Canvas.Font.Color := clRed;
      DBGLista.Canvas.Font.style := [];
    end;

  if tabelarfidias.AsInteger > 0 then
  begin
    DBGLista.Canvas.Font.Color := clRed;
    DBGLista.Canvas.Font.style := [];
  end;

  If gdSelected In State Then
    With (Sender As TDBGrid).Canvas Do
    Begin
      Brush.Color := PEG_COR_SELCGRID; // $004080FF;
      FillRect(fixRect);
      Font.Color := CLWHITE;
    End;

  with TFriendly(DBGLista) do
  begin
    { Get active record within grids TDataLink. The active record will be
      the current record in the dataset. Check against Row that we are
      trying to Draw, -1 to offset the column headings within grid. }

    if TDataLink(DataLink).ActiveRecord = Row - 1 then
    begin
      with Canvas do
      begin
        { set grids canvas to win highlight colour }
        Brush.Color := PEG_COR_SELCGRID; // $004080FF;
        { now redraw the cell, but highlighted }
        DefaultDrawColumnCell(fixRect, DataCol, Column, State);
      end;
    end;
  end;

  TDBGrid(Sender).DefaultDrawDataCell(fixRect, TDBGrid(Sender).Columns[DataCol].Field, State);

  if Column.FieldName = 'rfimarca' then
  begin

    // Desenha um checkbox no dbgrid

    DBGLista.Canvas.FillRect(Rect);

    Check := 0;
    if Self.tabela.FieldByName('rfimarca').AsString = '1' then
      Check := DFCS_CHECKED
    else
      Check := 0;

    R := Rect;
    InflateRect(R, -2, -2); { Diminui o tamanho do CheckBox }
    DrawFrameControl(DBGLista.Canvas.Handle, R, DFC_BUTTON, DFCS_BUTTONCHECK or Check);
  end;

end;

procedure Tfrabrf.DBGListaKeyPress(Sender: TObject; var Key: Char);
begin
  if Key in [#13, #27] then
    exit;

  inherited;
end;

procedure Tfrabrf.DBGListaSelecionadosDblClick(Sender: TObject);
begin
  inherited;
  ActRemoverSelecionado.Execute;
end;

procedure Tfrabrf.DBGListaSelecionadosDrawColumnCell(Sender: TObject; const Rect: TRect; DataCol: Integer; Column: TColumn; State: TGridDrawState);
var
  fixRect: TRect;
begin
  fixRect := Rect;

  If Odd(Dvbaixa.DataSet.RecNo) Then
    DBGListaSelecionados.Canvas.Brush.Color := PEG_COR_BASE
  Else
    DBGListaSelecionados.Canvas.Brush.Color := CLWHITE;

  With (Sender As TDBGrid).Canvas Do
  begin
    If gdSelected In State Then
    Begin
      Brush.Color := PEG_COR_SELCGRID;
      FillRect(fixRect);
      Font.Color := clBlack;
    End;

    if Column.FieldName = 'rfisituacao' then
      if vbaixarfisituacao.AsString = 'Baixa Parcial' then
        Font.Color := clRed;
  end;

  { Get active record within grids TDataLink. The active record will be
    the current record in the dataset. Check against Row that we are
    trying to Draw, -1 to offset the column headings within grid. }

  with TFriendly(DBGListaSelecionados) do
    if TDataLink(DataLink).ActiveRecord = Row - 1 then
      with Canvas do
      begin
        Brush.Color := PEG_COR_SELCGRID; { set grids canvas to win highlight colour }
        DefaultDrawColumnCell(fixRect, DataCol, Column, State); { now redraw the cell, but highlighted }
      end;

  TDBGrid(Sender).DefaultDrawDataCell(fixRect, TDBGrid(Sender).Columns[DataCol].Field, State);
end;

procedure Tfrabrf.diabaixaChange(Sender: TObject);
var
  vlnovadata: tdate;
  vlRecno: Integer;
  vldtbaixa: tdate;
  vlDiasCarencia: Integer;
  vldias: Integer;
  vlvcto: tdate;

begin
  inherited;
  try
    try
      vlRecno := tabela.RecNo;

      vlnovadata := diabaixa.Date;

      BRemoverTodos.Click;

      tabela.DisableControls;
      tabela.First;
      while not tabela.Eof do
      begin
        if tabelarfidtultbaixa.AsString <> '' then
        begin
          vldtbaixa := tabelarfidtultbaixa.AsDateTime;
        end
        else
        begin
          vldtbaixa := tabelarfivencimento.AsDateTime;
        end;

        tabela.Edit;
        if vlnovadata <= tabelarfidatadesc.AsFloat then
        begin
          tabelarfidesconto.AsFloat := uqtabelarfivalodesc.AsFloat;
        end
        else
        begin
          tabelarfidesconto.AsFloat := 0;
        end;

        if vlnovadata >= uqtabelarfidatamulta.AsFloat then
        begin

          tabelarfimulta.AsFloat := uqtabelarfivalomulta.AsFloat;
        end
        else
        begin
          tabelarfimulta.AsFloat := 0;
        end;
        vlDiasCarencia := 0;

        consulta.Close;
        consulta.SQL.Text := 'select cardiasjuros from car,rfi where rfi.carcodigo=car.carcodigo and rfi.rfichave=' + tabelarfichave.AsString;
        consulta.Open;

        if not consulta.IsEmpty then
        begin
          vlDiasCarencia := consulta.FieldByName('cardiasjuros').AsInteger;
        end;

        vlvcto := incday(vldtbaixa, vlDiasCarencia);

        vldias := DaysBetween(vlvcto, vlnovadata);

        if (vlvcto >= vlnovadata) then
        begin
          vldias := vldias * -1;
        end;

        if vldias <= 0 then
        begin
          tabelarfidias.AsInteger := 0;
        end
        else
        begin

          tabelarfidias.AsFloat := vldias;
        end;
        tabelarfijuros.AsCurrency := tabelarfimoradia.AsCurrency * tabelarfidias.AsInteger;

        tabelarfisaldogeral.AsCurrency := tabelarfisaldocapital.AsCurrency + tabelarfimulta.AsCurrency + tabelarfijuros.AsCurrency -
          tabelarfidesconto.AsCurrency;
        tabela.Post;
        tabela.Next;
      end;

      tabela.RecNo := vlRecno;
      tabela.EnableControls;

    except

    end;

  finally

    tabela.RecNo := vlRecno;
    tabela.EnableControls;

  end;

end;

procedure Tfrabrf.edbuscaKeyPress(Sender: TObject; var Key: Char);
begin
  if Key in [#13, #27] then
    exit;

  inherited;
end;

procedure Tfrabrf.lteAfterInsert(DataSet: TDataSet);
begin
  inherited;

  cfg.Close;
  cfg.Params[0].AsInteger := acesso.Filial;
  cfg.Open;

  lteltedata.AsFloat := cfgcfgdatapadrao.AsFloat;
  ltelteprincipal.AsFloat := 0;
  lteltejuros.AsFloat := 0;
  lteltemulta.AsFloat := 0;
  lteltedesconto.AsFloat := 0;
  lteltetotal.AsFloat := 0;
end;

procedure Tfrabrf.mGeradorClick(Sender: TObject);
var
  i: Integer;
begin
  inherited;

  AtualizaDVTBaixaLte;

  mrfrImprimir(Application, zcone, DVTBaixaLte, ExtractFilePath(Application.ExeName) + 'Relat\ReciboCRE.fr3', tiGerador, acesso.Usuario.ToString);
end;

Procedure Tfrabrf.somarbaixa;
var
  qtLinhasBaixa: Integer;
Begin

  if not lte.Active then
    exit;

  if lte.State = dsBrowse then
    lte.Edit;

  SaldoGeralOrig := 0;
  DescontoOrig := 0;
  MoraOrig := 0;
  MultaOrig := 0;
  SaldoCapitalOrig := 0;

  Self.ltelteprincipal.AsCurrency := 0;
  Self.lteltejuros.AsCurrency := 0;
  Self.lteltedesconto.AsCurrency := 0;
  Self.lteltemulta.AsCurrency := 0;
  Self.lteltetotal.AsCurrency := 0;

  vbaixa.DisableControls;
  vbaixa.First;
  qtLinhasBaixa := 0;
  While Not vbaixa.Eof Do
  Begin
    qtLinhasBaixa := qtLinhasBaixa + 1;
    Self.ltelteprincipal.AsCurrency := Self.ltelteprincipal.AsCurrency + Self.vbaixarfipgtocapital.AsCurrency;

    Self.lteltejuros.AsCurrency := Self.lteltejuros.AsCurrency + Self.vbaixarfijuros.AsCurrency;
    Self.lteltemulta.AsCurrency := Self.lteltemulta.AsCurrency + Self.vbaixarfimulta.AsCurrency;
    Self.lteltedesconto.AsCurrency := Self.lteltedesconto.AsCurrency + Self.vbaixarfidescontos.AsCurrency;
    Self.lteltetotal.AsCurrency := Self.lteltetotal.AsCurrency + Self.vbaixarfibaixado.AsCurrency;

    SaldoCapitalOrig := SaldoCapitalOrig + vbaixarfisaldocapital.AsCurrency;
    MultaOrig := MultaOrig + vbaixarfimultaoriginal.AsCurrency; // (vbaixarfimultaoriginal.AsCurrency - vbaixarfimultadispensada.AsCurrency);
    MoraOrig := MoraOrig + vbaixarfimoraoriginal.AsCurrency; // (vbaixarfimoraoriginal.AsCurrency - vbaixarfimoradispensada.AsCurrency);
    DescontoOrig := DescontoOrig + vbaixarfidescoriginal.AsCurrency;

    vbaixa.Next;
  End;

  SaldoGeralOrig := SaldoCapitalOrig + MultaOrig + MoraOrig - DescontoOrig;

  vbaixa.EnableControls;

  lte.Post;

  PlQtdeBaixa.Caption := IntToStr(qtLinhasBaixa);
End;

procedure Tfrabrf.TransferirTodosItem;
var
  i: Integer;
  rg: Integer;

begin
  { inherited; }
  try
    tabela.DisableControls;
    if (Self.tabelarfisaldogeral.AsCurrency > 0) then
    begin
      if not vbaixa.Locate('rfichave', Self.tabelarfichave.AsInteger, []) then
      begin
        vbaixa.Append;

        for i := 0 to 18 do
          vbaixa.Fields[i].AsString := tabela.Fields[i].AsString;

        vbaixarfipgtocapital.AsCurrency := vbaixarfisaldocapital.AsCurrency;
        vbaixarfibaixado.AsCurrency := vbaixarfisaldocapital.AsCurrency + Self.vbaixarfijuros.AsCurrency + Self.vbaixarfimulta.AsCurrency -
          Self.vbaixarfidescontos.AsCurrency;
        vbaixarfiemaberto.AsCurrency := vbaixarfisaldogeral.AsCurrency - vbaixarfibaixado.AsCurrency;

        vbaixarfisaldomora.AsCurrency := tabelarfisaldomora.AsCurrency;
        vbaixarfimoraoriginal.AsCurrency := vbaixarfijuros.AsCurrency;
        vbaixarfimoradispensada.AsCurrency := 0;
        vbaixarfimorarecebida.AsCurrency := vbaixarfimoraoriginal.AsCurrency - vbaixarfimoradispensada.AsCurrency;
        vbaixarfimultaoriginal.AsCurrency := vbaixarfimulta.AsCurrency;
        vbaixarfimultadispensada.AsCurrency := 0;
        vbaixarfimultarecebida.AsCurrency := vbaixarfimultaoriginal.AsCurrency - vbaixarfimultadispensada.AsCurrency;

        vbaixarfidescoriginal.AsCurrency := vbaixarfidescontos.AsCurrency;

        Self.vbaixarfisituacao.AsString := 'Baixa Total';
        vbaixa.Post;
        rg := vbaixa.RecNo;
      end;

      { somarbaixa;
        vbaixa.Locate('rfichave', Self.tabelarfichave.AsInteger, []); }

      Self.tabela.Edit;
      // tabelaincluido.AsInteger := 1;
      tabelarfimarca.AsInteger := 1;
      Self.tabela.Post;
    end;

    // tabela.Next;

  finally
    // calculartotais;
    tabela.EnableControls;
  end;
end;

procedure Tfrabrf.TransferirItem;
var
  i, v: Integer;
  rg: Integer;

begin
  { inherited; }
  try

    tabela.DisableControls;
    rg := tabela.RecNo;
    tabela.First;
    while not tabela.Eof do
    begin
      if (Self.tabelarfisaldogeral.AsCurrency > 0) and (tabelarfimarca.AsInteger = 1) then
      begin
        if not vbaixa.Locate('rfichave', Self.tabelarfichave.AsInteger, []) then
        begin
          vbaixa.Append;

          for i := 0 to 18 do
            vbaixa.Fields[i].AsString := tabela.Fields[i].AsString;

          vbaixarfipgtocapital.AsCurrency := vbaixarfisaldocapital.AsCurrency;
          vbaixarfibaixado.AsCurrency := vbaixarfisaldocapital.AsCurrency + Self.vbaixarfijuros.AsCurrency + Self.vbaixarfimulta.AsCurrency -
            Self.vbaixarfidescontos.AsCurrency;
          vbaixarfiemaberto.AsCurrency := vbaixarfisaldogeral.AsCurrency - vbaixarfibaixado.AsCurrency;

          vbaixarfisaldomora.AsCurrency := tabelarfisaldomora.AsCurrency;
          vbaixarfimoraoriginal.AsCurrency := vbaixarfijuros.AsCurrency;
          vbaixarfimoradispensada.AsCurrency := 0;
          vbaixarfimorarecebida.AsCurrency := vbaixarfimoraoriginal.AsCurrency - vbaixarfimoradispensada.AsCurrency;
          vbaixarfimultaoriginal.AsCurrency := vbaixarfimulta.AsCurrency;
          vbaixarfimultadispensada.AsCurrency := 0;
          vbaixarfimultarecebida.AsCurrency := vbaixarfimultaoriginal.AsCurrency - vbaixarfimultadispensada.AsCurrency;

          vbaixarfidescoriginal.AsCurrency := vbaixarfidescontos.AsCurrency;

          Self.vbaixarfisituacao.AsString := 'Baixa Total';
          vbaixa.Post;
          rg := vbaixa.RecNo;

        end;

        Self.tabela.Edit;
        tabelaincluido.AsInteger := 1;
        tabelarfimarca.AsInteger := 0;
        Self.tabela.Post;

        somarbaixa;
        vbaixa.Locate('rfichave', Self.tabelarfichave.AsInteger, []);

      end
      else
      begin
        tabela.Next;
      end;
    end;

    tabela.RecNo := rg;

    calculartotais;
    tabela.Refresh;
    tabela.EnableControls;

  finally
    tabela.EnableControls;
  end;
end;

procedure Tfrabrf.uqtabelaBeforeOpen(DataSet: TDataSet);
begin
  Self.uqtabela.ParamByName('clbcodigo').AsInteger := acesso.Usuario;
  inherited;

end;

procedure Tfrabrf.RegistraMovimentos;
begin
  ajustatiposdemovimento;

  vbaixa.DisableControls;
  vbaixa.First;

  while not vbaixa.Eof do
  begin
    (* Mora e Multa *)
    if vbaixarfimoraoriginal.AsFloat > 0 then
      RegistraMFI(vpTmfMoraRegistro, Self.vbaixarfimoraoriginal.AsCurrency - Self.vbaixarfisaldomora.AsCurrency);

    if vbaixarfimultaoriginal.AsFloat > 0 then
      RegistraMFI(vpTmfMultaRegistro, Self.vbaixarfimultaoriginal.AsCurrency);

    if vbaixarfimoradispensada.AsFloat > 0 then
      RegistraMFI(vpTmfMoraDispensada, Self.vbaixarfimoradispensada.AsCurrency);

    if vbaixarfimultadispensada.AsFloat > 0 then
      RegistraMFI(vpTmfMultaDispensada, Self.vbaixarfimultadispensada.AsCurrency);

    if vbaixarfimorarecebida.AsFloat > 0 then
    begin
      (* Se registro não possuia Mora ela é registrada com o total definido *)
      if vbaixarfimoraoriginal.AsFloat = 0 then
        RegistraMFI(vpTmfMoraRegistro, Self.vbaixarfimorarecebida.AsCurrency);

      RegistraMFI(vpTmfMoraPaga, Self.vbaixarfimorarecebida.AsCurrency);
    end;

    if vbaixarfimultarecebida.AsFloat > 0 then
    begin
      (* Se registro não possuia Multa ela é registrada com o total definido *)
      if vbaixarfimultaoriginal.AsFloat = 0 then
        RegistraMFI(vpTmfMultaRegistro, Self.vbaixarfimultarecebida.AsCurrency);

      RegistraMFI(vpTmfMultaPaga, Self.vbaixarfimultarecebida.AsCurrency);
    end;

    (* Descontos *)
    if vbaixarfidescontos.AsFloat > 0 then
      RegistraMFI(vpTmfDescontos, Self.vbaixarfidescontos.AsCurrency);

    (* Total Recebido *)
    if vbaixarfipgtocapital.AsFloat > 0 then
      RegistraMFI(vpTmfBaixas, Self.vbaixarfipgtocapital.AsCurrency - Self.vbaixarfidescontos.AsCurrency);

    vbaixa.Next;
  end;

  vbaixa.EnableControls;
end;

procedure Tfrabrf.RegistraMFI(tmfCodigo: Integer; valor: currency);
var
  vCcoChave: String;
  vFavorecido: String;
  vHistorico: String;
  vlMdaIdentificacao: string;

begin
  if valor = 0 then
    exit;

  ConsultaMfi.Close;
  ConsultaMfi.ParamByName('tmfcodigo').AsInteger := tmfCodigo;
  ConsultaMfi.ParamByName('rfichave').AsInteger := Self.vbaixarfichave.AsInteger;
  ConsultaMfi.ParamByName('ltechave').AsInteger := Self.lteltechave.AsInteger;
  ConsultaMfi.Open;

  if not ConsultaMfi.IsEmpty then
    exit;

  if not mfi.Active then
    mfi.Open;

  mfi.Append;
  mfirfichave.AsInteger := Self.vbaixarfichave.AsInteger;
  mfitmfcodigo.AsInteger := tmfCodigo;
  mfimoecodigo.AsInteger := 1;
  mfimfivalor.AsCurrency := valor;
  mfimfidata.AsFloat := diabaixa.Date; // Self.lteltedata.AsFloat;
  mfimfihistorico.AsString := '';
  mfimfivalorori.AsCurrency := valor;
  mfimfiparcela.AsInteger := 1;
  mfiflacodigo.AsInteger := acesso.Filial;
  mfi.Post;

  mlt.Close;
  mlt.SQL.Text := 'select  mltchave, mfichave, ltechave from mlt limit 1';
  mlt.Open;

  mlt.Append;
  mltmfichave.AsInteger := Self.mfimfichave.AsInteger;
  mltltechave.AsInteger := Self.lteltechave.AsInteger;
  mlt.Post;

  { *  Daniel - 05/04/2014
    ajuste para identificar a entidade e ajustar o favorecido no conta corrente da baixa
    * }

  cltv.Close;
  cltv.SQL.Text := 'select ccochave from clt where ltechave=' + Self.lteltechave.AsString;
  cltv.Open;

  cltv.First;
  while not cltv.Eof do
  begin

    vCcoChave := cltv.Fields[0].AsString;;

    if vCcoChave = '' then
      exit;

    consulta.Close;
    consulta.SQL.Text := 'select etdcodigo,ccofavorecido, ccohistorico, ccochave,cedcodigo from cco where ccochave=' + vCcoChave;
    consulta.Open;

    if consulta.RecordCount <> 1 then
      exit;

    IdentificaBaixa.Close;
    IdentificaBaixa.SQL.Text :=
      'SELECT mfi.mfivalor,  mlt.ltechave,  rfi.etdcodigo,  etd.etdidentificacao,  mfi.rfichave,  lte.tfdcodigo, rfi.rfinumero,dtl.mdacodigo, mdaidentificacao FROM mlt ';
    IdentificaBaixa.SQL.add('INNER JOIN mfi ON mlt.mfichave = mfi.mfichave ');
    IdentificaBaixa.SQL.add('INNER JOIN rfi ON mfi.rfichave = rfi.rfichave ');
    IdentificaBaixa.SQL.add('INNER JOIN etd ON rfi.etdcodigo = etd.etdcodigo ');
    IdentificaBaixa.SQL.add('INNER JOIN lte ON mlt.ltechave = lte.ltechave ');
    IdentificaBaixa.SQL.add('INNER JOIN dtl ON lte.ltechave = dtl.ltechave ');
    IdentificaBaixa.SQL.add('INNER JOIN mda ON dtl.mdacodigo = mda.mdacodigo ');
    IdentificaBaixa.SQL.add('WHERE mfi.tmfcodigo in (21,11) and mlt.ltechave=' + Self.lteltechave.AsString);
    IdentificaBaixa.Open;

    consulta.Edit;
    IdentificaBaixa.First;

    { if tmfCodigo = tmfPagamento then
      begin
      if consulta.Fields[4].AsInteger = 1 then
      vHistorico := 'Troco de pagto Títulos';
      end
      else
      begin

      if consulta.Fields[4].AsInteger = 0 then
      vHistorico := 'Troco ' + vHistorico; }
    vlMdaIdentificacao := '';
    IdentificaBaixa.First;
    while not IdentificaBaixa.Eof do
    begin
      if pos(IdentificaBaixa.Fields[8].AsString, vlMdaIdentificacao) = 0 then
      begin
        vlMdaIdentificacao := vlMdaIdentificacao + IdentificaBaixa.Fields[8].AsString + ',';
      end;

      IdentificaBaixa.Next;
    end;
    vlMdaIdentificacao := copy(vlMdaIdentificacao, 1, length(vlMdaIdentificacao) - 1);

    if IdentificaBaixa.Fields[5].AsInteger = tfdRecebimentos then
      vHistorico := 'Recto com ' + vlMdaIdentificacao + ' de Titulos Nº : '
    else
      vHistorico := 'Pagto com ' + vlMdaIdentificacao + ' de Titulos Nº : ';

    IdentificaBaixa.First;
    while not IdentificaBaixa.Eof do
    begin
      if IdentificaBaixa.RecordCount = 1 then
        consulta.Fields[0].AsString := IdentificaBaixa.Fields[2].AsString;

      if pos(IdentificaBaixa.Fields[3].AsString, vFavorecido) = 0 then
        vFavorecido := vFavorecido + IdentificaBaixa.Fields[3].AsString + ',';

      if pos(IdentificaBaixa.Fields[4].AsString, vHistorico) = 0 then
        vHistorico := vHistorico + IdentificaBaixa.Fields[6].AsString + ',';

      IdentificaBaixa.Next;
    end;

    { end; }
    consulta.Fields[1].AsString := copy(vFavorecido, 1, length(vFavorecido) - 1);

    if (consulta.FieldByName('cedcodigo').AsInteger = 0) and (tmfCodigo = tmfAPagar) then
    begin
      consulta.Fields[2].AsString := copy(vHistorico, 1, length(vHistorico) - 1);
    end;
    consulta.Post;

    consulta.Close;

    consulta.Close;
    consulta.SQL.Text := 'select etdcodigo,ccofavorecido, ccohistorico, ccochave,cedcodigo from cco where ccochave=' + vCcoChave;
    consulta.Open;

    consulta.Edit;
    consulta.Fields[2].AsString := copy(vHistorico, 1, length(vHistorico) - 1);
    consulta.Post;

    cltv.Next;
  end;

  { *  Daniel - 12/12/2014
    ajuste para identificar a entidade e ajustar o historico e o favorecido do troco no conta corrente da baixa
    * }

  cltv.Close;
  cltv.SQL.Text := 'select clt.ccochave, mdacodigo from clt, dtl where clt.ltechave=dtl.ltechave and clt.ltechave=' + IntToStr(Self.lteltechave.AsInteger + 1);
  cltv.Open;

  cltv.First;
  while not cltv.Eof do
  begin
    if cltv.Fields[1].AsInteger = mdaTrocoChequeTerceiros then
    begin
      vCcoChave := cltv.Fields[0].AsString;;

      if vCcoChave = '' then
        exit;

      consulta.Close;
      consulta.SQL.Text := 'select etdcodigo,ccofavorecido, ccohistorico, ccochave,cedcodigo from cco where ccochave=' + vCcoChave;
      consulta.Open;

      if consulta.RecordCount <> 1 then
        exit;

      IdentificaBaixa.Close;
      IdentificaBaixa.SQL.Text :=
        'SELECT mfi.mfivalor,  mlt.ltechave,  rfi.etdcodigo,  etd.etdidentificacao,  mfi.rfichave,  lte.tfdcodigo, rfi.rfinumero FROM mlt ';
      IdentificaBaixa.SQL.add('INNER JOIN mfi ON mlt.mfichave = mfi.mfichave ');
      IdentificaBaixa.SQL.add('INNER JOIN rfi ON mfi.rfichave = rfi.rfichave ');
      IdentificaBaixa.SQL.add('INNER JOIN etd ON rfi.etdcodigo = etd.etdcodigo ');
      IdentificaBaixa.SQL.add('INNER JOIN lte ON mlt.ltechave = lte.ltechave ');
      IdentificaBaixa.SQL.add('WHERE mfi.tmfcodigo in (21,11) and mlt.ltechave=' + Self.lteltechave.AsString);
      IdentificaBaixa.Open;

      consulta.Edit;
      IdentificaBaixa.First;

      if IdentificaBaixa.Fields[5].AsInteger = tfdRecebimentos then
      begin

        vHistorico := 'Troco Recto Títulos Nº: ';
        while not IdentificaBaixa.Eof do
        begin
          if IdentificaBaixa.RecordCount = 1 then
            consulta.Fields[0].AsString := IdentificaBaixa.Fields[2].AsString;

          if pos(IdentificaBaixa.Fields[3].AsString, vFavorecido) = 0 then
            vFavorecido := vFavorecido + IdentificaBaixa.Fields[3].AsString + ',';

          if pos(IdentificaBaixa.Fields[6].AsString, vHistorico) = 0 then
            vHistorico := vHistorico + IdentificaBaixa.Fields[6].AsString + ',';

          IdentificaBaixa.Next;
        end;

      end
      else
        vHistorico := 'Troco de pagto Títulos';


      // vHistorico := 'Troco Pagto Títulos Nº: ';

      consulta.Fields[1].AsString := copy(vFavorecido, 1, length(vFavorecido) - 1);
      consulta.Fields[2].AsString := copy(vHistorico, 1, length(vHistorico) - 1);
      consulta.Post;

      consulta.Close;

    end;
    cltv.Next;
  end;

end;

procedure Tfrabrf.ajustatiposdemovimento;
begin
  vpTmfBaixas := 0;

  vpTmfDescontos := 0;

  vpTmfMultaRegistro := 0;
  vpTmfMultaDispensada := 0;
  vpTmfMultaPaga := 0;

  vpTmfMoraRegistro := 0;
  vpTmfMoraDispensada := 0;
  vpTmfMoraPaga := 0;

  if StrToInt(Self.vtfdcodigo) = tfdPagar then
  begin
    vpTmfBaixas := tmfPagamento;
    vpTmfDescontos := tmfDescontoaCredito;

    vpTmfMoraRegistro := tmfJurosaDebito;
    vpTmfMoraDispensada := tmfJurosMoraDispensada;
    vpTmfMoraPaga := tmfPagamentoJuros;

    vpTmfMultaRegistro := tmfMultaaDebito;
    vpTmfMultaDispensada := tmfMultaDispensada;
    vpTmfMultaPaga := tmfPagamentoMulta;
  end
  else if StrToInt(Self.vtfdcodigo) = tfdReceber then
  begin
    vpTmfBaixas := tmfRecebimento;
    vpTmfDescontos := tmfDescontoaDebito;

    vpTmfMoraRegistro := tmfJurosaCredito;
    vpTmfMoraDispensada := tmfJurosMoraDispensada;
    vpTmfMoraPaga := tmfRecebimentoJuros;

    vpTmfMultaRegistro := tmfMultaaCredito;
    vpTmfMultaDispensada := tmfMultaDispensada;
    vpTmfMultaPaga := tmfRecebimentoMulta;
  end;
end;

procedure Tfrabrf.LimpaRegistros;
begin
  if not lte.Active then
    exit;

  mlt.Close;
  mlt.SQL.Text := 'SELECT mltchave, mfichave, ltechave FROM mlt WHERE ltechave=' + lteltechave.AsString;
  mlt.Open;

  while not mlt.Eof do
  begin
    consulta.Close;
    consulta.SQL.Text := 'DELETE FROM mfi WHERE mfichave = ' + mlt.FieldByName('mfichave').AsString;
    consulta.ExecSQL;
    mlt.Next;
  end;

  consulta.Close;
  consulta.SQL.Text := 'DELETE FROM mlt WHERE ltechave = ' + lteltechave.AsString;
  consulta.ExecSQL;

  consulta.Close;
  consulta.SQL.Text := 'DELETE FROM let WHERE ltechave = ' + lteltechave.AsString;
  consulta.ExecSQL;

  consulta.Close;
  consulta.SQL.Text := 'DELETE FROM lte WHERE ltechave = ' + lteltechave.AsString;
  consulta.ExecSQL;
end;

procedure Tfrabrf.AtualizaRFI;
begin
  vbaixa.DisableControls;
  vbaixa.First;
  while not vbaixa.Eof do
  begin
    consulta.Close;
    consulta.SQL.Text := 'UPDATE rfi SET rfi.srfcodigo = :srfcodigo WHERE rfichave = ' + vbaixarfichave.AsString;

    if Renegociacao then
      consulta.Params[0].AsInteger := srfRenegociado
    else if vbaixarfisituacao.AsString = 'Baixa Total' then
      consulta.Params[0].AsInteger := srfQuitado
    else if vbaixarfisituacao.AsString = 'Baixa Parcial' then
      consulta.Params[0].AsInteger := srfBaixaParcial;

    consulta.ExecSQL;

    consulta.Close;
    consulta.SQL.Text := 'select CalcMovimentoFinanceiro(' + vbaixarfichave.AsString + ')';
    consulta.ExecSQL;

    consulta.Close;
    consulta.SQL.Text := 'select CalcRegistroFinanceiro(' + vbaixarfichave.AsString + ')';
    consulta.ExecSQL;

    vbaixa.Next;
  end;
  vbaixa.EnableControls;
end;

procedure Tfrabrf.AjustaBaixaParcial(vValor: Double);
var
  vlSaldoBxParcial: Double;
  vlValorBaixado: Double;
  vlRegAjustado: Boolean;
  vlRecno: Integer;
begin
  vlRecno := 0;
  vlRegAjustado := False;
  vlValorBaixado := 0;
  vlSaldoBxParcial := 0;

  vbaixa.DisableControls;

  try
    vbaixa.First;
    while not vbaixa.Eof do
    begin

      vlValorBaixado := vlValorBaixado + vbaixarfibaixado.AsCurrency;

      case CompareValue(vlValorBaixado, vValor) of
        EqualsValue:
          begin
            vlRecno := vbaixa.RecNo;
            vlRegAjustado := True;
            vbaixa.Next;
          end;
        LessThanValue:
          vbaixa.Next;

        GreaterThanValue:
          if (vlRegAjustado) then
          begin
            if (vbaixa.RecNo > vlRecno) then
              RemoveTituloSelecionado
            else
              vbaixa.Next;
          end
          else
          begin
            vbaixa.Edit;

            vlSaldoBxParcial := vlValorBaixado - vValor;
            vlSaldoBxParcial := vbaixarfibaixado.AsCurrency - vlSaldoBxParcial;

            if vbaixarfimultarecebida.AsCurrency >= vlSaldoBxParcial then
            begin
              vbaixarfimultarecebida.AsCurrency := vlSaldoBxParcial;
              vlSaldoBxParcial := 0;
            end
            else
              vlSaldoBxParcial := vlSaldoBxParcial - vbaixarfimultarecebida.AsCurrency;

            if vbaixarfimorarecebida.AsCurrency >= vlSaldoBxParcial then
            begin
              vbaixarfimorarecebida.AsCurrency := vlSaldoBxParcial;
              vlSaldoBxParcial := 0;
            end
            else
              vlSaldoBxParcial := vlSaldoBxParcial - vbaixarfimorarecebida.AsCurrency;

            vbaixarfipgtocapital.AsFloat := vlSaldoBxParcial + vbaixarfidescontos.AsCurrency;

            vbaixarfiemaberto.AsCurrency := vbaixarfisaldocapital.AsCurrency - vbaixarfipgtocapital.AsCurrency;

            If vbaixarfiemaberto.AsCurrency = 0 Then
              Self.vbaixarfisituacao.AsString := 'Baixa Total'
            Else
              Self.vbaixarfisituacao.AsString := 'Baixa Parcial';

            vbaixarfimulta.AsCurrency := vbaixarfimultarecebida.AsCurrency;
            vbaixarfijuros.AsCurrency := vbaixarfimorarecebida.AsCurrency;

            vbaixarfibaixado.AsCurrency := vbaixarfipgtocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency -
              vbaixarfidescontos.AsCurrency;

            vbaixarfisaldogeral.AsCurrency := vbaixarfisaldocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency -
              vbaixarfidescontos.AsCurrency;

            vlRecno := vbaixa.RecNo;
            vlRegAjustado := True;
            vbaixa.Next;
          end;
      end;
    end;

    somarbaixa;
    calculartotais;

  finally
    vbaixa.EnableControls;
  end;
end;

function Tfrabrf.AjustarTodos: Boolean;
Var
  frmAjustaTotal: TfAjustaTotal;
  vlModalResult: Integer;

  (* Variáveis de Controle para ajuste das parcelas *)
  vlPercMulta: Double;
  vlTotalMulta, vlMaiorPercMulta: Double;
  vlRecNoMulta: Integer;
  vlPercMora: Double;
  vlTotalMora, vlMaiorPercMora: Double;
  vlRecNoMora: Integer;
  vlPercDesc: Double;
  vlTotalDesc, vlMaiorPercDesc: Double;
  vlRecNoDesc: Integer;
Begin

  vlPercMulta := 0;
  vlTotalMulta := 0;
  vlMaiorPercMulta := 0;
  vlRecNoMulta := 0;

  vlPercMora := 0;
  vlTotalMora := 0;
  vlMaiorPercMora := 0;
  vlRecNoMora := 0;

  vlPercDesc := 0;
  vlTotalDesc := 0;
  vlMaiorPercDesc := 0;
  vlRecNoDesc := 0;

  somarbaixa;

  frmAjustaTotal := TfAjustaTotal.Create(Self);
  frmAjustaTotal.vpUsuario := acesso.Usuario.ToString;
  try
    frmAjustaTotal.zcone := zcone;
    frmAjustaTotal.LteChave := lteltechave.AsString;
    frmAjustaTotal.UsrCodigo := acesso.Usuario.ToString;

    (* Identifica se é ajuste de Renegociação *)
    frmAjustaTotal.Renegociacao := Renegociacao;

    (* Valores originais *)
    frmAjustaTotal.SaldoCapitalOrig := SaldoCapitalOrig;
    frmAjustaTotal.MultaOrig := MultaOrig;
    frmAjustaTotal.MoraOrig := MoraOrig;
    frmAjustaTotal.DescontoOrig := DescontoOrig;
    frmAjustaTotal.SaldoGeralOrig := SaldoGeralOrig;

    (* Valores definidos atualmente *)
    frmAjustaTotal.SaldoCapital := ltelteprincipal.AsCurrency;
    frmAjustaTotal.Multa := lteltemulta.AsCurrency;
    frmAjustaTotal.Mora := lteltejuros.AsCurrency;
    frmAjustaTotal.Desconto := lteltedesconto.AsCurrency;

    vlModalResult := frmAjustaTotal.ShowModal;

    if not(vlModalResult = mrOk) then
      exit(False);

    lte.Edit;
    ltelteprincipal.AsCurrency := frmAjustaTotal.SaldoCapital;
    lteltemulta.AsCurrency := frmAjustaTotal.Multa;
    lteltejuros.AsCurrency := frmAjustaTotal.Mora;
    lteltedesconto.AsCurrency := frmAjustaTotal.Desconto;
    lteltetotal.AsCurrency := frmAjustaTotal.SaldoGeral;
    lte.Post;

    DifSaldoCapital := frmAjustaTotal.SaldoCapital - SaldoCapitalOrig;
    DifMulta := frmAjustaTotal.Multa - MultaOrig;
    DifMora := frmAjustaTotal.Mora - MoraOrig;
    DifDesconto := frmAjustaTotal.Desconto - DescontoOrig;
    DifSaldoGeral := frmAjustaTotal.SaldoGeral - SaldoGeralOrig;

    (* Libera Form fAjustaTotal *)
    frmAjustaTotal.Free;

    vbaixa.DisableControls;

    vbaixa.First;

    while not vbaixa.Eof do
    begin
      vbaixa.Edit;

      if DifMulta = 0 then
      begin
        vbaixarfimultarecebida.AsCurrency := vbaixarfimultaoriginal.AsCurrency;
        vbaixarfimultadispensada.AsCurrency := 0;
      end
      else if (DifMulta * -1) = MultaOrig then
      begin
        vbaixarfimultarecebida.AsCurrency := 0;
        vbaixarfimultadispensada.AsCurrency := vbaixarfimultaoriginal.AsCurrency;
      end
      else
      begin
        if MultaOrig > 0 then
          vlPercMulta := (vbaixarfimultarecebida.AsCurrency / MultaOrig)
        else
          vlPercMulta := (vbaixarfisaldocapital.AsCurrency / SaldoCapitalOrig);

        vbaixarfimultarecebida.AsCurrency := TBRound(vbaixarfimultaoriginal.AsCurrency + (DifMulta * vlPercMulta), 2);

        vbaixarfimultadispensada.AsCurrency := 0;

        (* Identifica se NÃO É BAIXA PARCIAL TOTAL e ajusta a multa dispensada *)
        if not(Abs(DifSaldoCapital) = SaldoCapitalOrig) then
          if vbaixarfimultarecebida.AsCurrency < vbaixarfimultaoriginal.AsCurrency then
            vbaixarfimultadispensada.AsCurrency := vbaixarfimultaoriginal.AsCurrency - vbaixarfimultarecebida.AsCurrency;

        (* Variáveis de controle para ajustar diferença de MULTA *)

        vlTotalMulta := vlTotalMulta + vbaixarfimultarecebida.AsCurrency;

        if vlPercMulta > vlMaiorPercMulta then
        begin
          vlMaiorPercMulta := vlPercMulta;
          vlRecNoMulta := vbaixa.RecNo;
        end;
      end;

      if DifMora = 0 then
      begin
        vbaixarfimorarecebida.AsCurrency := vbaixarfimoraoriginal.AsCurrency;
        vbaixarfimoradispensada.AsCurrency := 0;
      end
      else if (DifMora * -1) = MoraOrig then
      begin
        vbaixarfimorarecebida.AsCurrency := 0;
        vbaixarfimoradispensada.AsCurrency := vbaixarfimoraoriginal.AsCurrency;
      end
      else
      begin
        if MoraOrig > 0 then
          vlPercMora := (vbaixarfimorarecebida.AsCurrency / MoraOrig)
        else
          vlPercMora := (vbaixarfisaldocapital.AsCurrency / SaldoCapitalOrig);

        vbaixarfimorarecebida.AsCurrency := TBRound(vbaixarfimoraoriginal.AsCurrency + (DifMora * vlPercMora), 2);

        vbaixarfimoradispensada.AsCurrency := 0;

        (* Identifica se NÃO É BAIXA PARCIAL TOTAL e ajusta a multa dispensada *)
        if not(Abs(DifSaldoCapital) = SaldoCapitalOrig) then
          if vbaixarfimorarecebida.AsCurrency < vbaixarfimoraoriginal.AsCurrency then
            vbaixarfimoradispensada.AsCurrency := vbaixarfimoraoriginal.AsCurrency - vbaixarfimorarecebida.AsCurrency;

        (* Variáveis de controle para ajustar diferença de MORA *)

        vlTotalMora := vlTotalMora + vbaixarfimorarecebida.AsCurrency;

        if vlPercMora > vlMaiorPercMora then
        begin
          vlMaiorPercMora := vlPercMora;
          vlRecNoMora := vbaixa.RecNo;
        end;
      end;

      if DifDesconto = 0 then
        vbaixarfidescontos.AsCurrency := vbaixarfidescoriginal.AsCurrency
      else if (DifDesconto * -1) = DescontoOrig then
        vbaixarfidescontos.AsCurrency := 0
      else
      begin
        if DescontoOrig > 0 then
          vlPercDesc := (vbaixarfidescontos.AsCurrency / DescontoOrig)
        else
          vlPercDesc := (vbaixarfisaldocapital.AsCurrency / SaldoCapitalOrig);

        vbaixarfidescontos.AsCurrency := TBRound(vbaixarfidescoriginal.AsCurrency + (DifDesconto * vlPercDesc), 2);

        (* Variáveis de controle para ajustar diferença de DESCONTO *)

        vlTotalDesc := vlTotalDesc + vbaixarfidescontos.AsCurrency;

        if vlPercDesc > vlMaiorPercDesc then
        begin
          vlMaiorPercDesc := vlPercDesc;
          vlRecNoDesc := vbaixa.RecNo;
        end;
      end;

      vbaixarfipgtocapital.AsFloat := vbaixarfisaldocapital.AsCurrency;
      vbaixarfiemaberto.AsCurrency := 0;
      Self.vbaixarfisituacao.AsString := 'Baixa Total';

      vbaixarfijuros.AsCurrency := vbaixarfimorarecebida.AsCurrency;
      vbaixarfimulta.AsCurrency := vbaixarfimultarecebida.AsCurrency;

      vbaixarfibaixado.AsCurrency := vbaixarfipgtocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency - vbaixarfidescontos.AsCurrency;

      vbaixarfisaldogeral.AsCurrency := vbaixarfisaldocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency -
        vbaixarfidescontos.AsCurrency;

      vbaixa.Post;
      vbaixa.Next;
    end;

    if Abs(vlTotalMulta) <> 0 then
      if CompareValue(vlTotalMulta, lteltemulta.AsCurrency) <> EqualsValue then
      begin
        vbaixa.RecNo := vlRecNoMulta;
        vbaixa.Edit;

        vbaixarfimultarecebida.AsCurrency := vbaixarfimultarecebida.AsCurrency + (lteltemulta.AsCurrency - vlTotalMulta);

        if vbaixarfimultarecebida.AsCurrency < vbaixarfimultaoriginal.AsCurrency then
          vbaixarfimultadispensada.AsCurrency := vbaixarfimultaoriginal.AsCurrency - vbaixarfimultarecebida.AsCurrency
        else
          vbaixarfimultadispensada.AsCurrency := 0;

        vbaixarfimulta.AsCurrency := vbaixarfimultarecebida.AsCurrency;

        vbaixarfibaixado.AsCurrency := vbaixarfipgtocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency - vbaixarfidescontos.AsCurrency;

        vbaixarfisaldogeral.AsCurrency := vbaixarfisaldocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency -
          vbaixarfidescontos.AsCurrency;

        vbaixa.Post;
      end;

    if Abs(vlTotalMora) <> 0 then
      if CompareValue(vlTotalMora, lteltejuros.AsCurrency) <> EqualsValue then
      begin
        vbaixa.RecNo := vlRecNoMora;
        vbaixa.Edit;

        vbaixarfimorarecebida.AsCurrency := vbaixarfimorarecebida.AsCurrency + (lteltejuros.AsCurrency - vlTotalMora);

        if vbaixarfimorarecebida.AsCurrency < vbaixarfimoraoriginal.AsCurrency then
          vbaixarfimoradispensada.AsCurrency := vbaixarfimoraoriginal.AsCurrency - vbaixarfimorarecebida.AsCurrency
        else
          vbaixarfimoradispensada.AsCurrency := 0;

        vbaixarfijuros.AsCurrency := vbaixarfimorarecebida.AsCurrency;

        vbaixarfibaixado.AsCurrency := vbaixarfipgtocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency - vbaixarfidescontos.AsCurrency;

        vbaixarfisaldogeral.AsCurrency := vbaixarfisaldocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency -
          vbaixarfidescontos.AsCurrency;

        vbaixa.Post;
      end;

    if Abs(vlTotalDesc) <> 0 then
      if CompareValue(vlTotalDesc, lteltedesconto.AsCurrency) <> EqualsValue then
      begin
        vbaixa.RecNo := vlRecNoDesc;
        vbaixa.Edit;

        vbaixarfidescontos.AsCurrency := vbaixarfidescontos.AsCurrency + (lteltedesconto.AsCurrency - vlTotalDesc);

        vbaixarfibaixado.AsCurrency := vbaixarfipgtocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency - vbaixarfidescontos.AsCurrency;

        vbaixarfisaldogeral.AsCurrency := vbaixarfisaldocapital.AsCurrency + vbaixarfimulta.AsCurrency + vbaixarfijuros.AsCurrency -
          vbaixarfidescontos.AsCurrency;

        vbaixa.Post;
      end;

    if Abs(DifSaldoCapital) <> 0 then
      AjustaBaixaParcial(lteltetotal.AsCurrency);

    Result := True;

  finally
    vbaixa.EnableControls;
  end;
end;

Function Tfrabrf.Finaliza: Boolean;
type
{Tregistralotedata = Function(AOwner: TComponent; Conexao: tuniconnection; vchave: string; vtrmcodigo: string; principal: string; multa: string; juros: string; desconto: string;
  Acesso: TAcesso; vmodo: string; vDia: TDate; vPodeConvenio: Boolean = True; vTeclaFinalizador: Integer = 0; vValorFinalizador: Double = 0; vPodeCartoes: Boolean = True;
  pCtaCaixa: Integer = 0; vPodeTrocaDoacao: Boolean = True): string;}



Tregistralotedata = Function(AOwner: TComponent; Conexao: tuniconnection; vchave: string; vtrmcodigo: string; principal: string; multa: string;
  juros: string; desconto: string; Acesso: TAcesso; vmodo: string; vDia: TDate; vPodeConvenio: boolean = True; vTeclaFinalizador: Integer = 0;
  vValorFinalizador: Double = 0; vPodeCartoes: boolean = True; pCtaCaixa: Integer = 0; vPodeTrocaDoacao: boolean = True;
  vControleEntrega: boolean = false; vCcxchave: Integer = 0 ): string;


var
  Registra: Tregistralotedata;
  Pack: Cardinal;
  Vpri: String;
  vmulta: String;
  Vjur: String;
  Vdes: String;
  vPodeConvenio: Boolean;
  vPodeCartoes: Boolean;

  vmodo: String;
  vRetBaixa: String;
  i: Integer;

  VpTfdCodigo: Integer;
  vpCcoChave: string;
  vlMcgValorTotal: Double;
  vlRfiValorBaixa: Double;
  vlRfiPercentualBaixa: Double;

Begin
  Result := False;

  if lte.State <> dsBrowse then
    lte.Post;
  vbaixa.IndexFieldNames := 'rfichave';
  Pack := LoadPackage('modulos\mlte.bpl');
  If Pack <> 0 Then
    Try
      @Registra := GetProcAddress(Pack, PChar('registralotedata'));

      If Assigned(Registra) Then
      Begin
        Vpri := lteprincipal.Text;
        Vpri := BuscaTroca(Vpri, '.', '');
        Vpri := BuscaTroca(Vpri, '.', '');
        Vpri := BuscaTroca(Vpri, '.', '');

        if lteltetotal.AsFloat > 0 then
        begin
          Vdes := BuscaTroca(ltedesconto.Text, '.', '');
          Vdes := BuscaTroca(ltedesconto.Text, '.', '');

          Vjur := BuscaTroca(ltejuros.Text, '.', '');
          Vjur := BuscaTroca(ltejuros.Text, '.', '');

          vmulta := BuscaTroca(ltemulta.Text, '.', '');
          vmulta := BuscaTroca(ltemulta.Text, '.', '');

          vPodeConvenio := True;
          vPodeCartoes := True;

          let.Close;
          let.Open;

          adc.Close;
          adc.Open;

          vbaixa.DisableControls;
          try
            vbaixa.First;
            while not vbaixa.Eof do
            begin
              if adc.Locate('etdcodigo', vbaixaetdcodigo.AsInteger, []) then
              begin
                vPodeCartoes := False;
                break;
              end;
              vbaixa.Next;
            end;

            vbaixa.First;
            while not vbaixa.Eof do
            begin

              if not let.Locate('etdcodigo;ltechave', VarArrayOf([vbaixaetdcodigo.AsInteger, Self.lteltechave.AsInteger]), []) then
              begin
                let.Append;
                letetdcodigo.AsInteger := vbaixaetdcodigo.AsInteger;
                letltechave.AsString := Self.lteltechave.AsString;
                let.Post;
              end;

              vbaixa.Next;
            end;
          finally
            vbaixa.EnableControls;
          end;

          vchave := Self.lteltechave.AsString;

          if Renegociacao then
            vmodo := IntToStr(tfdRenegociacao) // Renegociação
          else if Self.vtfdcodigo = '2' then
            vmodo := IntToStr(tfdRecebimentos)
          else
            vmodo := IntToStr(tfdPagamentos);

          if not Renegociacao then
            vRetBaixa := Registra(Application, zcone, vchave, '1', Vpri, vmulta, Vjur, Vdes, acesso, vmodo, diabaixa.Date, vPodeConvenio, 0, 0, vPodeCartoes,  RecebCaixa.Conta, False)
          else
            vRetBaixa := Registra(Application, zcone, vchave, '1', Vpri, vmulta, Vjur, Vdes, acesso, vmodo, diabaixa.Date, vPodeConvenio, 120, lteltetotal.AsFloat, vPodeCartoes,
             0, False, vCcxchave);

          (* Usuário abandonou tela de definição das modalidades - mlte *)
          if vRetBaixa = '' then
          begin
            let.First;
            while not let.Eof do
            begin
              let.Delete;
            end;

            exit;
          end;

          RegistraMovimentos;

          { * Contabilização automativa, se configurada, para pagamentos e recebimentos * }
          if (cfgcfgusactb.AsInteger = 1) and (not Renegociacao) then
          begin

            consulta.Close;
            consulta.SQL.Text := 'select ccochave from clt where ltechave=' + Self.lteltechave.AsString;
            consulta.Open;

            vpCcoChave := consulta.Fields[0].AsString;

            ContabilizarBaixaRfi(Self.lteltechave.AsString, 1, vpCcoChave);

          end;
          if not Renegociacao then
            AtualizaRFI;

          if (cfgcfgusactb.AsInteger = 0) and (cfgcfgctbusaccg.AsInteger = 1) then
          begin
            mcgrfi.Close;
            mcgrfi.ParamByName('ltechave').AsString := Self.lteltechave.AsString;
            mcgrfi.Open;

            if not mcgrfi.IsEmpty then
            begin

              consulta.Close;
              consulta.SQL.Text := 'select ccochave from clt where ltechave=' + Self.lteltechave.AsString;
              consulta.Open;

              vpCcoChave := consulta.Fields[0].AsString;

              mcg.Open;

              while not mcgrfi.Eof do
              begin
                vlMcgValorTotal := vlMcgValorTotal + mcgrfimcgvalor.AsCurrency;
                mcgrfi.Next;

              end;

              mcgrfi.First;

              while not mcgrfi.Eof do
              begin
                if (mcgrfitmfcodigo.AsInteger <> 3) and (mcgrfitmfcodigo.AsInteger <> 12) then
                begin
                  if mcgrficcgcodigo.AsInteger <> 0 then
                  begin
                    vbaixa.Locate('rfichave', mcgrfirfichave.AsInteger, []);

                    vlRfiPercentualBaixa := vbaixarfipgtocapital.AsCurrency / vbaixarfivalor.AsCurrency;
                    if vpCcoChave <> '' then
                    begin
                      consulta.Close;
                      consulta.SQL.Text := 'select mcgchave from mcg where rfichave=' + mcgrfirfichave.AsString + ' and ccgcodigo=' + mcgrficcgcodigo.AsString +
                        ' and mcgtabela=' + QuotedStr('cco') + ' and mcgchaveorigem=' + vpCcoChave;
                      consulta.Open;

                      if consulta.IsEmpty then
                      begin

                        mcg.Append;
                        mcgccgcodigo.AsInteger := mcgrficcgcodigo.AsInteger;
                        mcgmcgvalor.AsCurrency := (mcgrfimcgvalor.AsCurrency * vlRfiPercentualBaixa); // ( mcgrfimcgvalor.AsCurrency/vlMcgValorTotal));
                        mcgmcgdata.AsDateTime := diabaixa.DateTime;
                        mcgmcgtabela.AsString := 'cco';
                        mcgmcgchaveorigem.AsString := vpCcoChave;
                        mcgmcgsituacao.AsInteger := 0;
                        mcgclbcodigo.AsInteger := acesso.Usuario;
                        mcgmcgregistro.AsString := agora(Application, zcone);
                        mcgrfichave.AsInteger := mcgrfirfichave.AsInteger;
                        mcg.Post;
                      end;
                    end;
                  end;
                end;
                mcgrfi.Next;
              end;

            end;


            // multas e juros

            mcgrfi.Close;
            mcgrfi.ParamByName('ltechave').AsString := Self.lteltechave.AsString;
            // mcgrfi.FilterSQL:='tmfcodigo in (12,13)';
            mcgrfi.Open;

            if not mcgrfi.IsEmpty then
            begin

              consulta.Close;
              consulta.SQL.Text := 'select ccochave from clt where ltechave=' + Self.lteltechave.AsString;
              consulta.Open;

              vpCcoChave := consulta.Fields[0].AsString;

              mcg.Open;

              while not mcgrfi.Eof do
              begin
                if vbaixa.Locate('rfichave', mcgrfirfichave.AsInteger, []) then
                begin

                  if (vbaixarfijuros.AsCurrency + vbaixarfimulta.AsCurrency) > 0 then
                  begin
                    if vpCcoChave <> '' then
                    begin
                      consulta.Close;
                      consulta.SQL.Text := 'select mcgchave from mcg where ccgcodigo=' + cfgccgmultajuros.AsString + ' and mcgchaveorigem=' + vpCcoChave +
                        ' and mcgtabela=' + QuotedStr('cco');
                      consulta.Open;

                      if consulta.IsEmpty then
                      begin

                        mcg.Append;
                        mcgccgcodigo.AsInteger := cfgccgmultajuros.AsInteger;
                        mcgmcgvalor.AsCurrency := vbaixarfijuros.AsCurrency + vbaixarfimulta.AsCurrency;
                        mcgmcgdata.AsDateTime := diabaixa.DateTime;
                        mcgmcgtabela.AsString := 'cco';
                        mcgmcgchaveorigem.AsString := vpCcoChave;
                        mcgmcgsituacao.AsInteger := 0;
                        mcgclbcodigo.AsInteger := acesso.Usuario;
                        mcgmcgregistro.AsString := agora(Application, zcone);
                        mcgrfichave.AsInteger := vbaixarfichave.AsInteger;
                        mcg.Post;
                      end;

                    end;
                  end;

                end;
                mcgrfi.Next;
              end;

            end;

          end;

          AtualizaDVTBaixaLte;
          if not Renegociacao then
            if Self.vtfdcodigo = '2' then
            begin
              if fileexists(ExtractFilePath(Application.ExeName) + 'Relat\ReciboCRE.fr3') then
                mrfrImprimir(Application, zcone, DVTBaixaLte, ExtractFilePath(Application.ExeName) + 'Relat\ReciboCRE.fr3', tiImprimir, acesso.Usuario.ToString)
            end
            else
            begin
              if fileexists(ExtractFilePath(Application.ExeName) + 'Relat\ReciboCPA.fr3') then
                mrfrImprimir(Application, zcone, DVTBaixaLte, ExtractFilePath(Application.ExeName) + 'Relat\ReciboCPA.fr3', tiImprimir,
                  acesso.Usuario.ToString);

            end;

          Result := True;

        End;
      End;
    Finally
      // DoUnLoadPackage(Application, Pack);
    End;
End;

procedure Tfrabrf.Carregar;
begin
  cfg.Connection := zcone;
  cfg.Open;
  diabaixa.Date := StrToDate(hoje(Application, zcone));
  diabaixa.MinDate := StrToDate(hoje(Application, zcone)) - 365;
  diabaixa.MaxDate := StrToDate(hoje(Application, zcone));
  vpccxchave:=0;
  { if (StrToInt(vtfdcodigo) = tfdPagar) or (cfgcfgusabol.AsInteger = 0) then
    DeletarColuna('bolnossonumero', DBGLista); }

  inherited Carregar;

  CarregarColunas(DBGListaSelecionados);

end;

function Tfrabrf.ContabilizarBaixaRfi(vLteChave: string; vtdgcodigo: Integer; vCcoChave: string): Boolean;
var
  Registra: TContabilizacaoBaixaRfi;
  vlPackMCtz: Cardinal;

begin
  vlPackMCtz := LoadPackage('modulos\mctz.bpl');
  if vlPackMCtz <> 0 then
    try
      @Registra := GetProcAddress(vlPackMCtz, PChar('ContabilizacaoBaixaRFI'));

      if Assigned(Registra) then
        Result := Registra(Application, zcone, acesso.Usuario.ToString, vLteChave, IntToStr(vtdgcodigo), vCcoChave);

    finally
      DoUnLoadPackage(Application, vlPackMCtz);
    end;
end;

procedure Tfrabrf.AtualizaDVTBaixaLte;
var
  i: Integer;
begin
  if not VTBaixaLte.Active then
    VTBaixaLte.Open;

  VTBaixaLte.Clear;

  vbaixa.DisableControls;
  vbaixa.First;
  while not vbaixa.Eof do
  begin
    VTBaixaLte.Append;
    for i := 0 to vbaixa.FieldCount - 1 do
      VTBaixaLte.Fields[i] := vbaixa.Fields[i];

    VTBaixaLteltechave.AsInteger := lteltechave.AsInteger;
    VTBaixaLteQtdRegistros.AsInteger := vbaixa.RecordCount;
    VTBaixaLte.Post;

    vbaixa.Next;
  end;

  vbaixa.EnableControls;
end;

end.
